# PdfText.py
"""
Classes for managing the production of formatted text, i.e. a chapter.
PdfChapter()
PdfParagraph()
PdfString()
"""
from PdfDoc import PdfDocument
from PdfFontMetrics import PdfFontMetrics
import math

# global
metrics = PdfFontMetrics()
FNfontkey = 'F3'
FNfontsize = 5

# function copied from stackoverflow
# https://stackoverflow.com/questions/28777219/basic-program-to-convert-integer-to-roman-numerals
from collections import OrderedDict
def write_roman(num):
	roman = OrderedDict()
	roman[1000] = "M"
	roman[900] = "CM"
	roman[500] = "D"
	roman[400] = "CD"
	roman[100] = "C"
	roman[90] = "XC"
	roman[50] = "L"
	roman[40] = "XL"
	roman[10] = "X"
	roman[9] = "IX"
	roman[5] = "V"
	roman[4] = "IV"
	roman[1] = "I"
	def roman_num(num):
		for r in roman.keys():
			x, y = divmod(num, r)
			yield roman[r] * x
			num -= (r * x)
			if num <= 0:
				break
	return "".join([a for a in roman_num(num)]).lower()


class PdfChapter( object ):
	"""
	PdfChapter is the container for stand-alone amount of formatted text, such as a
	chapter of text.  It may have headings, multiple paragraphs, and changes of 
	font within a section of text such as a paragraph. It begins with a new page
	and terminates with an end page.
	
	It contains PdfParagraphs()
	
	It may have a single PdfString as a heading and a single  PdfString as a footer.
	instance variables:
	paragraphs []
	footnotes  PdfFootNotes
	pdf a PdfDoc instance
	header
	footerStyle - [ 'RomanRight','None', ...
	prow
	pcol
	lineIncrement
	pageNumber  initialized to 1
	
	
	"""

	
	def __init__( self, doc ):
		"""
		Initializer for PdfChapter
		The PDFDoc instance passed as <doc> should be already initialized into a new page.
		chapter printing starts at the top of the current page.
		"""
		self.paragraphs = []
		self.footnotes = PdfFootNotes( doc )
		self.currentParagraph = None
		self.currentString = None
		self.pdf = doc
		self.header = None
		self.footerStyle = None
		self.prow = 0
		self.pcol = 0
		self.lineIncrement  = doc.lineHeight * doc.lineHeightFactor
		self.pageNumber = 1

	def setFooterStyle(self, pStyle):
		assert pStyle in [ 'RomanRight','None'], "Unknown footer style: "+pStyle
		self.footerStyle = pStyle
		
	def addParagraph( self, para):
		"""
		Add <para> to the list of paragraphs
		"""
		self.paragraphs.append( para )
		
	def footerLines(self):
		"""
		Return the number of rows required for the optional footer
		"""
		if self.footerStyle is None or self.footerStyle == 'None':
			return 0
		else:
			return 2
			
	def headerLines(self):
		"""
		return the number of rows required for the optional header
		"""
		if self.header is None:
			return 0
		else:
			return 2
	
		
	def prepare( self ):
		# calculate the total length, in points, of all strings in all paragraphs.
		linewidth = self.pdf.getLineWidth('p') 
		# print(' Building lines of length '+ str( linewidth ))
		for para in self.paragraphs:
			# length of each string. Probably redundant. 
			for s in para.strings:
				s.length = metrics.strLength( s.fontkey, s.fontsize, s.string )
			# now within each paragragh, build lines - which may be multiple strings or
			# more often may be subsections of strings. 
			para.buildLines( linewidth )
			
	def newPage(self ):
		"""
		uses Chapter().pdf to invoke a new page in the pdf document.
		Increments pagenumber
		sets chapter prow and pcol to 0
		"""
		self.pdf.newPage()
		# is there a header string?
		self.pageNumber += 1
		self.prow = 0
		self.pcol = 0
		
	def endPage(self, footNotesCtr = 0, fnOrd = 1):
		if footNotesCtr > 0:
			print('printing footnotes')
			self.footnotes.printFootNotes( footNotesCtr, fnOrd, self.prow )
			# ef printFootNotes( self, qty, firstNum,  pRow):
		if self.footerStyle is None:
			pass
		elif self.footerStyle == 'RomanRight':
			s = write_roman(self.pageNumber)
			br = self.pdf.getBottomRow('p')
			rc = self.pdf.getLineWidth('p')
			self.pdf.write( rc,br, s,'r','p')
		self.pdf.endPage()
		
	def process(self ):
		"""
		PdfChapter.process( PdfDoc )
		Print the chapter. Start a new page at the beginning. End whatever page is current
		at the end
		"""
		
		
		# self.newPage( )
		self.pdf.setTextState()
		
		# go paragraph by paragraph, lines by lines.
		
		initial = True
		
		self.lineIncrement = self.pdf.lineHeight * self.pdf.lineHeightFactor
	

		
		
		for para in self.paragraphs:
			para.printParagraph( self )
		self.endPage( )
			
		
	def stretch(self,  lns,  amt):
		"""
		insert spaces until the length of the set to strings has been
		increased by <amt> points.
		"""
		ret = []
		amtToAdd = amt
		while amtToAdd > 2:
	
			for l in lns:
				ol = l.length
				
				l.stretch( amtToAdd )
				# retuce amtToAdd by the increase in length of the string
				amtToAdd = amtToAdd - ( l.length - ol )
				
				if amtToAdd <= 2 :
					break;
		return lns		
		
		
		
		
		

class PdfParagraph( object  ):
	"""
	PdfParagraph represents a body of text. It may be one-line, such as a chapter (or section)
	header, it may be a long paragraph.  It contains  of a list of PdfString objects- it may contain one string, it
	may contain many.  For all of its components, they are produced sequentially and share the
	same justification: left, center, right, full l c r f
	A chapter heading would often be one short line of text, in a larger or more distinct font,
	and centered.
	Properties:
	alignment  [ 'l','c','r','j']
	indent  points
	tail    rows
	strings = []
	lines = None or []
	
	"""
	def __init__( self, alignment, indent = 0, tail = 1 ):
		"""
		all elements in a PdfParagraph share the same justification.
		<indent> is used for the first line of text. It is in points.
		<tail> moves the chapter row counter down tail * linecrement points.
		"""
		assert alignment in [ 'l','c','r','j']
		self.alignment = alignment
		self.indent = indent
		self.tail = tail
		self.strings = []
		self.lines = None
		
		
	def addString(self, fontkey, fontsize, string, footnote = None):
		"""
		Construct a PdfString from the parameters and add to the strings list
		"""
		self.strings.append( PdfString( fontkey, fontsize, string, footnote))
		
	
	def buildLines( self,  linewidth, ):
		"""
		This method takes all of the strings and breaks them up fit within individual lines. 
		The end result is an array of lines that each fit on a single line regardless of font
		changes (within reason). It does this by spliting PdfStrings that overflow a line
		into multiple shorter PdfStrings. And combing short strings.
		The <lines> attribute will contain one or more PdfStrings, so be printed on the
		same line. 
		
		Within a paragraph the first line may have an indent, and therefore e shorter
		"""	
		self.lines = []
		
		
		
		workingLine = []
		
		
		
		workingLen = 0
		# spaceLen = metrics.strLength(self.fontkey, self.fontsize, ' ')
		ctr = 0
		ps = None
		# the first line of a paragraph may have an indent.
		targetlen = linewidth - self.indent
		for s in self.strings:
			ps = s.split2( targetlen )
			workingLine.append(  ps )
			
			targetlen = targetlen - ps.length
			# print('added '+ps.string+' new targetlen is '+str(targetlen))
			# we are at the end if a line when s.length > 0
			# is s.length == 0 then the current line may not be full
			while s.length > 0:
				self.lines.append( workingLine )
	
				workingLine = []
				targetlen = linewidth
				ps = s.split2( targetlen )
				targetlen = targetlen - ps.length	
				workingLine.append(  ps )	
			# at this point s is consumed. targetlen is reduced as necessary, The
			# next string - perhaps in a different font - may fit, in full or in part
			# on the same line
			if targetlen < 10:
				self.lines.append( workingLine)
				workingLine = []
				targetlen = linewidth
				
		if len(workingLine) > 0:
			self.lines.append( workingLine )
	# now fully populated para.lines
	
	def documentLines(self):
		
		"""
		print out the complete lines with total length for each
		"""	
		for ln in self.lines:
			s = ''
			x = 0
			for l in ln:
				s += l.string
				x += l.length
			print( "{:4.0f}".format(x)+": "+s)
	
	def printParagraph(self, chapter):
		"""
		<chapter> is a PdfChapter. It is needed because it has access to endPage() and newPage()
		methods. And it tracks the chapter page number.
		chapter().pdf is a pdfDoc which is used for the printing.
		This method prints the paragraphs, beginning at the current row and at column 0.
		If there is insufficient room for one or more rows then the chapter.endPage()
		and chapter.newPage() methods are invoked.
		"""
		# self.documentLines()
		if self.lines is None:
			self.buildLines(doc.getLineWidth('p'))
		self.pcol = self.indent
		firstLine = True
		lineCount = len( self.lines )
		lineCtr = 0
		fnCtr = 0 # footnote counter
		for ln in self.lines:
			lineCtr += 1
			if  chapter.prow >= chapter.pdf.getBottomRow('p') - (chapter.footerLines() * (chapter.lineIncrement)) - chapter.footnotes.height(fnCtr):
				chapter.endPage( fnCtr  )
				fnCtr = 0
				chapter.newPage(  )
			if firstLine:
				chapter.pcol = self.indent
				firstLine = False
			else:
				chapter.prow += chapter.lineIncrement
				if firstLine:
					chapter.pcol = self.indent
					firstLine = False
				else:
					chapter.pcol = 0
			# how many point in this line
			lnlen = 0
			# calculate the length of the line, after removing any trailing spaces
			# from the end of the ln
			ln[-1].setString( ln[-1].string.rstrip())
			for l in ln:
				lnlen += l.length
			gap = chapter.pdf.getLineWidth('p') - lnlen
			if lineCtr == 1:
				gap = gap - self.indent
			if self.alignment == 'c':	
				# bump pcol by half the difference between string length and line length
				chapter.pcol = gap / 2
			elif self.alignment == 'r':
				chapter.pcol = gap
			elif self.alignment == 'j':
				# need to allocate gap among Strings
				# unless it is the last line
				if lineCtr < lineCount:
					ln = chapter.stretch( ln, gap)								
					
			for l in ln:
				# each line [ ln ] in self.lines is a list of 1 or more print statements, all to
				# be on the same line. If there are multiple print statements they probably
				# use different fonts
				# set position to next Line
				f = l.string.count('^')
				if f > 0:
					print('footnote found in '+l.string)
				chapter.pdf.setFont( l.fontkey, l.fontsize )
				chapter.pdf.write(chapter.pcol, chapter.prow , l.string, 'l','p')
				chapter.pcol += l.length
		if self.tail > 0:
			chapter.prow += self.tail * chapter.lineIncrement

		
		
			
	
class PdfString( object ):
	"""
	PDFString is a continuous bit of text in a common font. It may end
	with a footnote.
	"""

	def __init__( self, fontkey, fontsize, string, footnote = None):
		"""
		Initialize a new string, invoke setLength()
		"""
		assert fontsize > 0
		self.fontkey = fontkey
		self.fontsize = fontsize
		self.string = string
		self.footnote = footnote
		self.setLength()
	
	def concat(self, pText):
		"""
		Concatenate <pText> to the existing string, and invokes setLength()
		"""
		self.string = self.string + pText ;
		self.setLength()
	def setLength(self):
		"""
		set the length property based on metrics.strLenth
		"""
		self.length = metrics.strLength( self.fontkey, self.fontsize, self.string)
	def setString(self, t):
		"""
		reset the string property with <t> and invoke self.setLength()
		"""
		self.string = t
		self.setLength()
	def findChars(self,  c ):
		"""
		return a list of the indexes of all occurrences of <c> in self.string.
		May be useful for full justification
		"""
		ret = []
		for i in range(0,  len(self.string)):
			if self.string[i] == c:
				ret.append(i)
		return ret
			
	def split2(self, strLen):
		"""
		Splits a string. Returns a new PdfString that has a string <= strLen
		Modifes self, removing that portion of the string.  
		1. if the length of the string is 0 then it returns None
		2. If the length is < <strLen> then it returns a clone of itself,
		   and sets itself to an empty string of length 0
		3. If there is no space in self.string then the same as #2 above
		4. If the very first word in self.string is longer than strLen then
			it returns a PdfString with that first word. So if self.string
			is not empty then it returns a string of some length that may
			be greater than strLen
		"""
		ret = None
		if len(self.string) == 0:
			return None
		elif self.length <= strLen:
			ret = PdfString(self.fontkey, self.fontsize, self.string)
			self.setString('')
		elif self.string.find(' ') < 0:
			ret = PdfString(self.fontkey, self.fontsize, self.string)
			self.setString('')
		else:
			# build a new string.
			wrkStr = self.string
			
			newStr = ''
			newLen = 0
			
			# if there is some content and at least 1 space return the characters
			# up to and including the first space no matter now long
			newStr = wrkStr[ 0: wrkStr.find(' ')+ 1]	
			wrkStr = wrkStr[ wrkStr.find(' ')+ 1 :]		
			newLen = metrics.strLength( self.fontkey, self.fontsize, newStr)
			while newLen < strLen and len(wrkStr) > 0:
				nxtStr = wrkStr[ 0: wrkStr.find(' ')+1]
				nxtLen = metrics.strLength(self.fontkey,self.fontsize, nxtStr)
				if newLen + nxtLen <= strLen:
					newStr += nxtStr
					newLen += nxtLen
					wrkStr = wrkStr[ wrkStr.find(' ')+1 :] 
				else:
					# print('Could not fit in' + str(nxtLen))
					break
			ret = PdfString(self.fontkey, self.fontsize, newStr)
			ret.setLength()
			self.setString( wrkStr)
			
				
				
		self.setLength()
		return ret
		
	def stretch(self, amt):
		"""
		loop though self.string once, adding spaces to existing spaces, until
		the string has been traversed or each space has been padded once. So
		will not necessarily stretch the string to the full amount.	The <amt>
		to be added may be spread among multiple strings.
		"""
		spaceLen = metrics.strLength( self.fontkey, self.fontsize, ' ')	
		added = 0
		newStr = ''
		if amt < 2:
			return self
		elif self.length < 10:
			return self
		for c in self.string:
			if c == ' ' and added < amt :
				newStr += c + ' '
				added += spaceLen
			else:
				newStr += c

		self.setString( newStr )
				
			
			
			
class PdfFootNotes( object ) :
	"""
	Manage footnotes within a PDF Chapter
	"""			
	def __init__(self, doc):
		"""
		<doc> is a PdfDocument instance
		initializes self.fontKey to F3 self.fontSize to 7.
		self.lineHeightFactor = 1.2
		Starts with an empty list of footnotes.
		"""
		self.pdf = doc
		self.fontKey = 'F3'
		self.fontSize = 7
		self.footNotes = []
		self.lineHeightFactor = 1.2
		
	
	def addFootNote(self, note):
		"""
		add <note> to the list of footnotes
		"""
		self.footNotes.append( note )
	import math	
	def height(self, nRows):
		"""
		returns the vertical space, in points, needed to print the first <nRows> footnotes
		Begins with a horizontal line, so justs from 0 to (1 + number of footnotes) * lineheight * lineHeightFactor 
		"""
		if len(self.footNotes) == 0:
			ret =  0
		else:
			lineWidth = self.pdf.getLineWidth('p')
			ret = 1
			for n in self.footNotes:
				i = math.ceil( metrics.strLength(self.fontKey,self.fontSize, n) / lineWidth)
				ret += i
		return ret
	def printFootNotes( self, qty, firstNum,  pRow):
		"""
		Print the first <qty> footnotes, popping them from the list as they are printed.
		Footnotes are "consumed" as they are printed.
		Begin their numbering with <firstNum>
		begin at row <pRow> in pixels
		Do nothing is there are no footnotes, or if qty is 0
		"""
		if len(self.footNotes) > 0 and qtr > 0:
			# draw a short horizontal line 
			# drawLine(self, pX1, pY1, pX2, pY2, pUnit=None, pWidth=None)
			self.pdf.pushFont( self.fontKey, self.fontSize )
			self.pdf.drawline(0, pRow, 2 * 72, pRow,'p',1)
			pRow += self.lineHeight
			while qty > 0:
				s = self.footNotes.pop(0)
				qtr -= 1
				self.pdf.write(0,pRow,   str(firstNum)+'.','l','p')
				self.pdf.write(2 * self.fontSize, pRow, s,'l','p')
				pRow += (self.fontSize * self.lineHeightFactor)
			
		
		
		
		
			
		
		
	
	
		
		




