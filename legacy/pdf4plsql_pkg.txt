-- Start of DDL Script for Package RANGER.PDF4PLSQL
-- Generated 27-Oct-2005 15:35:19 from RANGER@ZINC.WORLD

create or replace 
PACKAGE PDF4PLSQL IS
-- Copyright Gary Menchen
-- these subtypes are mostly to provide documentation
-- for parameters, etc.
subtype handle is number(5,0);
subtype point is number;

--@
--@ These types are declared here primarily so they can be used as parameters,
--@ or within subsequent type declarations.
--@
type RegisteredFontKeys is table of varchar2(20) index by binary_integer;
type OffsetTable is table of number(10) index by binary_integer;
type xRefLableTable is table of varchar2(25) index by binary_integer;
type ObjectNumberTable is table of number(5) index by binary_integer;  
type stream_t is table of varchar2(2000) index by binary_integer;
type xref_rec is record
  (offset number,
   generation number,
   label varchar2(25));
type xref_tbl is varray(10) of xref_rec;    

--@ The pdfPage data structure may eventually have its own public routines
--@ As of now it should not be referenced   
type PdfPage is record (
  PageObj# number(5) := 0,
  StreamObj# number(5) := 0,
  SizeObj# number(5) := 0,
  ParentObj# number(5),
  Page# number(5) := 0,
  Fontlist varchar2(200) := '',
  XObjectList varchar2(100) :='',
  GraphicsStream stream_t,
  name varchar2(10),
  TextStream stream_t);
  
--@ document is the main data structure.  It is normally the first parameter
--@ in all procedures and functions (except the initiating function that
--@ returns a new document.  Note that for performance reasons the document,
--@ when used as a parameter, should always be in out nocopy.  Leaving out
--@ the nocopy makes performance MUCH slower.  
--@ See property list below. No elements of this structure should be accessed
--@ directly.
type document is record (
  CurrentFontKey varchar2(20) := 'F1',
  CurrentFontSize number(3) := 12,
  defaultUnit varchar2(1) := 'p',   -- default unit of measurement
                                    -- p point, r row c col,i inches
  Offset number(10) := 0,           -- tracks position in overall stream
  CurrentPage# number(5) := 0,      -- physical page number
  NextObj# number(5)  :=  1,        -- next available object number 
  CurrentParent# number(10) := 3,   -- parent object# of current page
  Page pdfPage,                     -- Current page 
  Name varchar2(100),               -- File Name, etc
  LineHeight   point := 11,     -- average line height,current font, in points
  CharWidth    point := 7.1,     -- average character width,current font, in points
  PageHeight   point := 11 * 72, -- page height is in points
  PageWidth    point := 8.5 * 72, -- page width is in points
  TopMargin    point := 0.4 * 72 ,  --  starting point. Rows are relative to top margin.
  LeftMargin   point := 0.4 * 72  ,  -- Columns are relative to this point.
  RightMargin  point := 0.4 * 72,   -- typical non-printable area
  BottomMargin point := 0.4 * 72,
  the_blob blob,
  Target varchar2(100),              -- email address, etc
  pageobjlist ObjectNumberTable,
  pageparentlist ObjectNumberTable,
  fontKeyList RegisteredFontKeys,
  fontObj#list ObjectNumberTable,
  -- components for cross reference table
  xRefOffset OffsetTable,
  xRefLabel XRefLableTable ,
  fileName varchar2(100),
  currentRow point,      -- INTERNAL USE: Current Y position, in points
  currentCol point,       -- INTERNAL USE: Current X positon, in points
  currentState number(1)      -- INTERNAL USE, tracking status of document
  );
--@  
--@ Property List
--@
--@ The various properties listed below generally correspond to elements of
--@ the document data structure, which should not be accessed or set directly.
--@ Not all properties may have both get and set methods. The table below lists
--@ which are available. Most are described in more detail below. All in this 
--@ table have for form. pUnit is an optional parameter when the property refers
--@ to a position on a page, and is available whenever the property refers to a
--@ position within a page.
--@ value := getProperty( pDoc, pUnit );
--@ setProperty( pDoc, Value, pUnit );
--@ More complex set procedures are not listed in this table.

--@ Blob        get       Returns the blob the document was written to, if any
--@ BottomMargin get set
--@ BottomRow   get       row coordinate of last addressable row
--@ DefaultUnit get set     Does not take a pUnit parameter
--@ FileName    get set
--@ LineHeight  get set                   
--@ LineWidth   get set   Line width minus margins. Represents rightmost column
--@ LeftMargin  get set
--@ Nextrow     get
--@ PageNumber  get set
--@ RightMargin get set
--@ Target      get set   
--@ TopMargin   get set

 
  
  




  
  
--
-- Get/Set functions/procedures
--@ differentiating between portrait and landscape is as simple as specifying
--@ the width and height, in inches, as either 8 1/3 by 11 or 11 by 8 1/2.
--@ There is no intrinsic requirement that a page in a pdf doument actually
--@ correspond to any physical paper size.  
Procedure SetPageSize(p in handle,
                      pHeight in number ,
                      pWidth in number ,
                      pUnits in varchar2 default null);
                      
--@ getLineWidth returns the page width minus the left and right margins. In r/c units
--@ it should represent the last addressable position, and so can be used to 
--@ write text at the right side of the page, using an alignment if 'r' for 
--@ right justified.                      
function getLineWidth(p in handle, pUnit in varchar2 default null)
  return number;
--@ Getblob returns the blob that the pdf was written to 
Function GetBlob(p in handle) return blob;
--@ The next procedures are used to set margins: top, left, right.
procedure setLeftMargin( p in handle,pMargin in number, pUnit in varchar2 default null);
function getLeftMargin( p in handle, pUnit in varchar2 default null)
  return number;
procedure setRightMargin( p in handle,pMargin in number, pUnit in varchar2 default null);
function getRightMargin( p in handle, pUnit in varchar2 default null) return number;

function getRightColumn(p in handle,pUnit in varchar2 default null) return number;
procedure setTopMargin( p in handle, pMargin in number, pUnit in varchar2 default null);
function getTopMargin( p in handle,pUnit in varchar2) return number;

procedure setBottomMargin( p in handle, pMargin in number, pUnit in varchar2 default null);
function getBottomMargin( p in handle,pUnit in varchar2) return number;

procedure setMargins(p in handle, pTop in number, pLeft in number,
  pBottom in number, pRight in number, pUnit in varchar2 default null);

procedure setTarget(p in handle, pTarget in varchar2);
function getTarget(p in handle) return varchar2;


--@ the point of allowing line height to be set with something other than points is
--@ that it can be set as a multiple of the current line height. i.e. if current
--@ line height is 11 points, and it is set to .5, 'c' then it would become 5 or 6.
--@ In general this is a crude way of dealing with font sizes because the package
--@ is not yet aware of font metrics (which would not be too difficult to do)
--@ Note that getLineHeight, with a unit of r or c, should return 1.  
procedure setLineHeight(p in handle, pHeight in number, pUnit in varchar2 default null);
function getLineHeight(p in handle, pUnit in varchar2) return number;

procedure setPageNumber(p in handle, pNumber in number);
function getPageNumber(p in handle) return number;

--@ beginDoc initiates a document                          
Procedure beginDoc( p in handle,
                    pDocName in varchar2 := null);
--@ endDoc ends the document                      
Procedure endDoc( p in handle);
--@ getFileName returns the name of the odocument  
Function GetFileName( p in handle) return varchar2;
Procedure setFileName( p in handle, pValue varchar2);

procedure setDebugging ( value in boolean);


--@ newPdfDoc returns a new document that can be worked with
function newPdfDoc  return handle;

--@ newPage is used to initiate a page  
procedure newPage(p in handle);
--@ endpage terminates a page
procedure endPage(p in handle);
procedure endPageEncode(p in handle);

/*
  The pre-defined fonts, with their keys are
  Courier,'F1'
  Courier-Bold,'F1B'
  Courier-Oblique,'F1I'
  Courier-BoldOblique,'F1IB'
  Helvetica,'F2'
  Helvetica-Bold,'F2B'
  Helvetica-Oblique,'F2I'
  Helvetica-BoldOblique,'F2IB'
  Times-Roman,'F3'
  Times-Bold,'F3B'
  Times-Italic,'F3I'
  Times-BoldItalic,'F3IB'
  Symbol,'F4'
  ZapDingbats,'F5'
*/
--@ Set font based on font key
procedure setFont(p in handle,
                  pFontKey in varchar2,
                  pFontSize in number);
procedure setFontByName(p in handle,
                        pFontName in varchar2,
                        pFontSize in number);
Function FindFontByKey(pFontKey in varchar2) return number;
function getFontkey( pFontName in varchar2) return varchar2;

-- setCharWidth is used to determine a position on the x-axis
-- based upon a single per character value. This is only
-- an estimate where variable width fonts are used
procedure setCharWidth(p in handle, pPoints in number);
function strLength(pFontKey in varchar2, pFontSize in number, pString in varchar2)
  return number; -- returns width of string for specified font, in points
--@ Units of measurement are points (1/72 inch), inches
--@ and row/col. The latter would vary depending upon
--@ the font,so use may be problematic... The default unit of measure is
--@ the point. Options include 
--@ r, c (row or column; interchangeable, based on current font
--@ i inches
--@ p points
--@ When output is generated all units are converted to points, since that is
--@ the only positioning unit recognized by pdf                            
Procedure SetDefaultUnit(p in handle, pUnit in varchar2);
Function GetDefaultUnit( p in handle) return varchar2;
--@ convertunits is a handdy function that converts units from one format to
--@ another. Its use is primarily internal
function convertunits(p in handle,
                      pUnits in number, 
                      pFrom varchar2, 
                      pTo varchar2) return number;
  
--@ Standard text printing procedure
procedure Write(p in handle,
                pX in number, -- horizontal / column position
                pY in number, -- vertical / row position
                pString in varchar2, -- text to display
                pAlign in varchar2 default 'l', -- left, center, right
                pUnit in varchar2 default null); -- point,inch, row/col
--@ Write on the next line. A pass through the write
procedure WriteNext(p in handle,
                pX in number, -- horizontal / column position
                pString in varchar2, -- text to display
                pAlign in varchar2 default 'l', -- left, center, right
                pUnit in varchar2 default null); -- point,inch, row/col
--@ Write on the current line. A pass through to write
procedure WriteCol(p in handle,
                pX in number, -- horizontal / column position
                pString in varchar2, -- text to display
                pAlign in varchar2 default 'l', -- left, center, right
                pUnit in varchar2 default null); -- point,inch, row/col
--@ center a string on line <pY>. A passthrough to write    
procedure writeCenteredInLine(p in handle,
          pY in number, -- the row
          pString in varchar2,
          pUnit in varchar2 default null);
--@ writeOut writes at the current row and column position. DOES NOT WRAP.          
procedure writeout(p in handle, pString in varchar2);
--@ nextRow returns the position of the row below the last row addressed. Useful
--@ when checking when to end a page          
function nextRow(p in handle,pUnit in varchar2 default null) return number;
function getBottomRow(p in handle,punit in varchar2 default null) return number;
function getCurrentRow(p in handle, pUnit in varchar2 default null) return number;
function getCurrentCol(p in handle, pUnit in varchar2 default null) return number;
procedure setCurrentRow(p in handle, pValue in number, pUnit in varchar2 default null);
procedure setCurrentCol(p in handle, pValue in number, pUnit in varchar2 default null);
-- free rows returns the number of available lines after the current row, i.e.
-- (bottomrow - currentrow / lineheight) 
function getFreeRows( p in handle) return number;
          
--@
--@ Graphics Routines
--@
--@ drawLine draws a line between any two points. A horizontal line would
--@ simly have pY1 = pY2, and a vertical line would have pX1 = pX2.
--@ pWidth should be specified in "user space units". This width setting should
--@ remain in effect for the document (including for the Rectangle
--@ procedure) until changed. 0 is the thinnist possible line, and may not be
--@ visible. 1.0 is the default.
procedure DrawLine(p in handle,
                   pX1 in number,
                   pY1 in number,
                   pX2 in number,
                   pY2 in number,
                   pUnit in varchar2 default null,
                   pWidth in number default null);
Procedure Rectangle(p in handle,
                    pX in number,
					pY in number,
					pWidth in number,
					pHeight in number,
					pUnit in varchar2 default null,
                    pLineWidth in number default null);
procedure Shade(p in handle,
                pX1 in number,
                pY1 in number,  -- the lower position on y axis
                pX2 in number,
                pY2 in number,  -- upper position on y axis
                pScale in number default null,
                pUnit in varchar2 default null);
procedure Shade1(p in handle,
                pX1 in number,
                pY1 in number,
                pX2 in number,
                pY2 in number,
                pScale in number default null,
                pUnit in varchar2 default null);

procedure GreyBar( p in handle,
                   pY in number, pUnit in varchar2 default null);
procedure PageBorder(p in handle);
procedure ellipse(p in handle,
                  pX in number, pY in number,
                  pRadiusX in number, pRadiusY in number,
                  pUnit in varchar2 default null,
                  pLinewidth in number default null);
                   
procedure lineAcrossPage(p in handle,pY in number,pUnit in varchar2 default null);
procedure setTextState(p in handle,
                       pCharSpace in number default 0,
                       pwordSpace in number default 0,
                       pScale in number default 100,
                       pLeading in number default 0,
                       pRender in number default 0,
                       pRise in number default 0);
                       
-- setGrayScale can be used to print on shades. Using a value
-- of one prints in white (or reverse).
procedure setGrayScale(p in handle,pScale in number default 0);
procedure waterMark(p in handle, pText in varchar2);
/*
procedure defineJpgXOjbect(pDoc in out nocopy document,
                               pImage in blob,
                               pName in varchar2,
                               pWidth in number,
                               pHeight in number,
                               pBitsPer in number,
                               pDevice in varchar2 default 'DeviceGray',
                               pImageLib in varchar2 default 'ImageB'
                               );
*/                               
procedure defineImageXObject( p in handle,
                              pImage in blob,                   
                              pName in varchar2,              -- Im1
                              pWidth in number,
                              pHeight in number,
                              pBitsPerComponent in number,    -- 8 | 1
                              pColorSpace in varchar2 default null,  -- null | DeviceRGB
                              pImageMask in varchar2 default null, -- null | true
                              pImageLib in varchar2 default null, -- null, ImageB, ImageC
                              pFilter in varchar2 default null    -- DCTDecode if jpeg
                              );                       
procedure showImage(p in handle,
                    pName in varchar2,
                    pX in number, pY in number,
                    pUnit in varchar2 default null,
                    pScaleX in number default null, 
                    pScaleY in number default null,
                    pSkewX in number default 0, 
                    pSkewY in number default 0,
                    pGrayScale in number default 0);                               
-- and for form XObjects
procedure newFormXObject(p in handle, pName in varchar2);
procedure endFormXOBject( p in handle);
procedure showForm(p in handle, pName in varchar2);

procedure imbedPalatino(p in handle);

END; -- Package spec
/

-- Grants for Package
grant execute on PDF4PLSQL to LOAN
/
grant execute on PDF4PLSQL to GC
/
grant execute on PDF4PLSQL to LOAN_PROGRAMMER
/
grant execute on PDF4PLSQL to OPS$MENCHEN_GE
/

create or replace 
PACKAGE BODY PDF4PLSQL
IS
type font_table_rec is record
  ( fontname varchar2(30),
    fontkey varchar2(20) );
type xobject_table_rec is record
  ( name varchar2(20),
    object# number,
    width number,
    height number,
    device varchar2(20),
    imageLib varchar2(20),
    imageMask varchar2(4) );
    
type xobject_table_typ is table of xobject_table_rec index by binary_integer;
        
type font_table_typ is table of font_table_rec index by binary_integer;


type pdfDocTable_type is table of document
  index by binary_integer;
docTable pdfDocTable_type;

-- Package data structures, equivilent to class data structures
pvXObjectTable xobject_table_typ;

pvFontTable font_table_typ;
pvDebugging boolean := false;

pvLicensed boolean;
--
function checkLicense return boolean
is
begin
  return true;
end checkLicense;
function resolveUnit(p in handle,pUnit in varchar2, pContext in varchar2)
return varchar2
is
  vUnit varchar2(1);
begin
  vUnit := nvl(pUnit,docTable(p).DefaultUnit);
  if vUnit in ('r','c') then
    if pContext in ('r','c') then
      vUnit := pContext;
    end if;
  end if;
  return vUnit;
end resolveUnit;        

function getLineWidth(p in handle, pUnit in varchar2 default null)
  return number
is
  vReturn number(10);
  vUnit varchar2(1);
begin
  vUnit := resolveUnit(p,pUnit,'c');
  vReturn := docTable(p).PageWidth
    - docTable(p).Leftmargin
    - docTable(p).RightMargin;
  vReturn := convertUnits( p,vReturn,'p',vUnit);
  return vReturn;
end;  
                              

function nextObj#( p in handle) return number
is
  vReturn number(5);
begin
  vReturn := docTable(p).nextObj#;
  docTable(p).nextObj# := docTable(p).nextObj# + 1;
  return vReturn;
end;

Procedure put(p in handle, pMessage in varchar2)
is
  vMessage varchar2(32000) := ltrim(rtrim(pMessage));
  vLength number(10);
begin
  if docTable(p).the_blob is null then
    raise_application_error(-20001,'document not yet initialized with beginDoc');
  end if;
  vLength := Length(vmessage) + 2;
  dbms_lob.writeappend(docTable(p).the_Blob, vlength,
    utl_raw.cast_to_raw( vMessage||CHR(13)||CHR(10)));
  docTable(p).offset := docTable(p).offset + vLength;
end Put;
procedure addXRef(p in handle,
                  pNum in number, 
                  pOffset in number, 
                  pLabel in varchar2)
is
begin
  docTable(p).xRefOffset(pNum) := pOffset;
  docTable(p).xRefLabel(pNum) := pLabel;
  -- generations are all 0 
end addXRef;
function registerFont( p in handle,pFontKey in varchar2) return number
is
  vPtr integer := 0;
  vFontPtr integer := 0;
  vObject# integer := 0;
begin
  -- this function checks if pFontKey has been registered in the current document.
  -- if it has not then it does so. It returns the object number of the font
  -- in the document


  if docTable(p).fontKeyList.exists(1) then
    for i in docTable(p).fontKeyList.first..docTable(p).fontKeyList.last loop

      if docTable(p).fontKeyList(i) = pFontKey then
        vPtr := i;
      end if;
    end loop;
  end if;
  if vPtr = 0 then

    vFontPtr := FindFontbyKey(pFontKey);
    if vFontPtr = 0 then
      raise_application_error(-20001,'Invalid font key ' || pFontKey);
    end if;    
    -- this font has not been registered in the document
    vPtr := nvl( docTable(p).fontkeyList.last ,0) + 1;
    docTable(p).fontKeyList(vPtr) := pFontKey;
    docTable(p).fontObj#List(vPtr) := nextObj#( p );
    addxRef(p, docTable(p).fontObj#List(vPtr),
              docTable(p).Offset,'font');
    put(p,to_char(docTable(p).fontObj#List(vPtr))||' 0 obj');
    put(p,'<< /Type /Font');
    put(p,'   /Subtype /Type1');
    put(p,'   /Name /' || docTable(p).fontKeyList(vPtr)); -- F1');
    put(p,'   /BaseFont /' || pvFontTable(vFontptr).fontname) ; -- Courier');
    put(p,'   /Encoding /WinAnsiEncoding');
    put(p,'>>');
    put(p,'endobj');
  end if;
  vObject# := docTable(p).fontObj#List(vPtr);
  return vObject#;    
end registerFont; 


procedure writeHeader( p in handle) is
  vBucket number;
begin
  docTable(p).offset := 0;
  put(p,'%PDF-1.2');
  -- Try some high order bytes on the second line. This is a convention
  -- to prevent some programs from treating this as an ascii text file,
  -- and possibly converting eol characters
  put(p,'%%' || chr(25) || chr( (15 * 16) + 2) || chr( (15 * 16) + 3)
    || chr( (13 * 16) + 15) || chr( (14 * 16) + 3));
  -- Write the catalog. Pages in object 3
  AddxRef(p,1,docTable(p).offset,'Catalog');
  put(p,'1 0 obj');
  put(p,'<<');
  put(p,'/Type /Catalog');
  put(p,'/Pages 3 0 R');
  put(p,'/Outlines 2 0 R');
  put(p,'>>');
  put(p,'endobj');
  addxRef(p,2,docTable(p).Offset,'Outlines');
  put(p,'2 0 obj');
  put(p,'<<');
  put(p,'/Type /Outlines');
  put(p,'/Count 0');
  put(p,'>>');
  put(p,'endobj');
  -- add a procset
  addxRef(p,4,docTable(p).Offset,'ProcSet');
  put(p,'4 0 obj');
  put(p,'  [/PDF /Text /ImageB /ImageC]');
  put(p,'endobj');
  -- Add some information
  addxRef(p,5,docTable(p).Offset,'General Info');
  put(p,'5 0 obj');
  put(p,'<<');
  put(p,'/CreationDate (D:'||to_char(sysdate,'yyyymmddhhmiss')||')');
  put(p,'/Author ('||user||')');
  put(p,'/Producer (PDF for PL/SQL by Gary Menchen)');
  put(p,'>>');
  put(p,'endobj');
  docTable(p).nextObj# := 6;

end writeHeader;

Procedure writePages( p in handle,
                      pObject in number, pParent in number default null)
  is
  -- Goal is to have about 6 page object as kids to a page object.
  -- The parent number is assigned to each /page object by the GetNewPage
  -- function. For each page.parentobj# value we write a single /pages object,
  -- write the /Page object numbers to the kids list,and, if we are not at
  -- the end of the list of page objects, add the parentobj# of the subsequent
  -- page. As a result each /Pages object will have a kids list that contains
  -- up to 6 /Page objects.  The kids list will end with a reference to another
  -- /Pages object if we are not at the end of the list of /Page objects.
  
  -- Not that the parameters after pHandle are not used.
  vParent number(6) := null;
  vObject number(6) := null;
  i integer;
  vLine varchar2(200);
  vTotalPages number(5);
  vPageCtr number(2); -- number of /page objects listed in a /pages object
begin
  vTotalpages := docTable(p).pageObjList.last - docTable(p).PageObjList.first + 1;
  i := docTable(p).PageObjList.first;
--  for kk in pvPageList.first..pvPageList.last loop
--    dbms_output.put_line('% ' || to_char(kk) || ' Obj ' || to_char(pvPageList(kk).PageObj#)
--      || ' parent ' || to_char(pvPageList(kk).ParentObj#));
--  end loop;

  while i <= docTable(p).PageObjList.last loop
    -- begin the pages object
    vObject := docTable(p).pageParentList(i);
    AddxRef(p,vObject,docTable(p).offset,'Pages');
    put(p,to_char(vObject) || ' 0  obj');
    put(p,'<< /Type /Pages');
	if i > docTable(p).PageObjList.first then
	  put(p,'/Parent ' || to_char(vParent)|| ' 0 R');
	end if;
	vLine := '/Kids [';
    vPageCtr := 0;
	while i <= docTable(p).PageObjList.Last and vObject = docTable(p).pageParentList(i) loop
	  vLine := vLine || to_char(docTable(p).PageObjList(i)) || ' 0 R ';
	  vPageCtr := vPageCtr + 1;
	  i := i + 1;
	end loop;
	-- Check if we need to add a /Pages object to the end of the kids list
	if i <=  docTable(p).PageObjList.Last then
	  vLine := vLine || to_Char(docTable(p).pageParentList(i)) || ' 0 R ';
      vParent := vObject;
      -- dbms_output.put_line('%Parent changed to ' || to_Char(vParent));
	end if;
	vLine := vLine || ']';
	Put(p, vLine);
	put(p, '/Count ' || to_char(vTotalPages));
	put(p,'>>');
	put(p,'endobj');
	vTotalPages := vTotalPages - vPageCtr;

  end loop;
end writePages;

Procedure writeXRef( p in handle) is
  vOffset number(10);
  vOffsetMask varchar2(10) := '0000000000';
  vGenMax varchar2(5) := '00000';
  vLine varchar2(500);
  vCtr number(5) := 0;
  i integer;
  vNext integer;
begin
  writePages( p, 3, null);
  vOffset := docTable(p).Offset;
  put(p,'xref');
  vNext := nextObj#(p);
  put(p,'0 ' || to_char(vNext));
  put( p,trim(to_char(0,vOffsetMask)) || ' ' || trim(to_char(65535,vGenMax))||' f');
  i := docTable(p).xRefOffset.first;
  while i <= docTable(p).xRefOffset.last loop
    put( p,  trim(to_char(docTable(p).xRefOffset(i),vOffsetMask))||' '
           || trim(to_char(0,vGenMax))||' n');
    i := docTable(p).xRefoffset.next(i);
  end loop;
  put(p,'trailer');
  put(p,'<< /Size ' || to_char(vNext));
  put(p,'   /Root 1 0 R');
  put(p,'   /Info 5 0 R');
  put(p,'>>');
  put(p,'startxref');
  put( p,to_char(vOffset));
  put(p, '%%EOF');
end writeXRef;

procedure checkMeasurementUnit(pUnit in varchar2) is
begin
  if pUnit in ('r','c','i','p') then
    null;
  else
    raise_application_error(-20010,'invalid measurement unit: <'||pUnit||'>');
  end if;
end CheckMeasurementUnit;


Procedure addFont(pFontName in varchar2, pFontKey in varchar2)
-- Adds a font to the internal font table. Note that the font
-- is not written to a pdf file until it is requested...
is
  vNamePtr number(5);
  vKeyPtr number(5);
  vPtr integer;
begin
  if pvFontTable.exists(1) then
    vPtr := pvFontTable.last + 1;
  else
    vPtr := 1;
  end if;
  pvFontTable(vptr).fontname := pFontName;
  pvFontTable(vPtr).FontKey := pFontKey;
end addFont;
--
-- Public Interface
--
-- newPdfdoc returns a new document
function newPdfDoc return handle
is
  vDoc document;
  vHandle handle;
begin
  if doctable.exists(1) then
    vHandle := docTable.last + 1;
  else
    vHandle := 1;
  end if;
  docTable(vhandle) := vDoc;
  return vHandle;
end newPdfDoc;
Procedure beginDoc( p in handle,
                    pDocName in varchar2 := null)
is
  vName varchar2(60);
begin
  if pDocName is not null then
    docTable(p).FileName := pDocName;
  end if;
  dbms_lob.createtemporary(docTable(p).the_Blob,true);
  pvXObjectTable.delete;
  writeHeader( p );
  setFont(p,'F1',10);
end beginDoc;                      
Procedure endDoc(p in handle) is
begin
  WritexRef( p );
end endDoc;
function getFileName( p in handle) return varchar2 is
  vReturn varchar2(200);
begin
  vReturn := nvl(docTable(p).FileName,'pdftest.pdf');
  if instr(vReturn,'.') = 0 then
    vReturn := rtrim(vReturn) || '.pdf';
  end if;  
  return vReturn;
end getFileName;
Procedure setFileName( p in handle, pValue varchar2)
is
begin
  docTable(p).fileName := pValue;
end setFileName;    
procedure newFormXObject(p in handle, pName in varchar2)
is
  vPage pdfPage;
  vPtr integer;
begin
  -- almost like a page. We need to track graphic and text streams, fonts
  -- and other resources  
  vPage.pageObj# := nextObj#( p );
  vPage.name := pName;
  
  if pvXObjectTable.exists(1) then
    vPtr := pvXObjectTable.last + 1;
  else
    vPtr := 1;
  end if;
  pvXObjectTable(vPtr).name := pName;
  pvXObjectTable(vPtr).object# := vPage.pageObj#;
  -- but doesn't use a separate object for a stream...
  -- set as the current page so that the streams will be built
  docTable(p).page := vPage;
  setFont(p, docTable(p).CurrentFontKey,docTable(p).CurrentFontSize);
  docTable(p).currentRow := 0;
  docTable(p).currentCol := 0;
end newFormXObject;  
procedure newPage(p in handle)
is
  vPage pdfPage;
  vPtr binary_integer;
begin
  vPage.pageObj# := nextObj#( p );
  vPage.streamObj# := nextObj#( p );
  vPage.sizeObj# := nextObj#( p );
  docTable(p).currentPage# := docTable(p).currentPage# + 1;
  vPage.page# := docTable(p).currentPage#;
  -- add this page to the list of pages, i.e.
  if docTable(p).pageObjList.exists(1) then
    vPtr := docTable(p).pageObjList.last + 1;
  else
    vPtr := 1;
  end if;
  docTable(p).pageObjList(vPtr) := vPage.pageObj#;
  if mod(vPtr,6) = 0 then
    -- switch to a new parent
    docTable(p).currentParent# := nextObj#( p );
  end if;
  docTable(p).pageParentList(vPtr) := docTable(p).currentParent#;
  vPage.parentObj# := docTable(p).currentParent#;
  docTable(p).page := vPage;
  setFont(p, docTable(p).CurrentFontKey,docTable(p).CurrentFontSize);
  docTable(p).currentRow := 0;
  docTable(p).currentCol := 0;
end newPage;
procedure endPageEncode(p in handle)
is
  vLen number(6) := 0;
  vString varchar2(32000);
  v integer;
begin
  -- output the three objects, and register in xref table
  addXRef(p,docTable(p).Page.PageObj#,docTable(p).offset, 'Page ' || to_char(docTable(p).Page.Page#));
  put(p,to_char(docTable(p).Page.pageObj#)||' 0 obj');
  put(p,'<< /Type /Page');
  put(p,'   /Parent ' || to_char(docTable(p).Page.ParentObj#) || ' 0 R');
  put(p,'  /MediaBox [0 0 ' || to_char(docTable(p).PageWidth)|| ' '
    || to_Char(docTable(p).PageHeight) || ']');
  /*  
  if docTable(pHandle).Orientation = 'Landscape' then
    put(p,'   /MediaBox [0 0 792 612]');
    docTable(p).PageHeight := 612; -- page height is in points
    docTable(p).PageWidth  := 792; -- page width is in points
    docTable(p).TopMargin  := 8.0 * 72; --  starting point. Rows are relative to top margin.
  else -- default    
    put(p,'   /MediaBox [0 0 612 792]');
  end if;
  */    
  put(p,'   /Contents ' || to_char(docTable(p).Page.StreamObj#)||' 0 R');
  put(p,'   /Resources << /ProcSet 4 0 R ');
  put(p,'                 /Font << ' || docTable(p).Page.FontList ||' >>');
  if length(ltrim(docTable(p).page.xObjectList)) > 0 then
    put(p,'   /XObject << ' || docTable(p).page.XobjectList||' >>');
  end if;  
  put(p,'              >>');
  put(p,'>>');
  put(p,'endobj');
  -- now the stream
  AddxRef(p,docTable(p).page.StreamObj#,docTable(p).Offset,'Stream ' || to_char(docTable(p).Page.Page#));
  put(p,To_char(docTable(p).Page.StreamObj#) || ' 0 obj');
  put(p,'<< /Length ' || to_char(docTable(p).Page.SizeObj#)||' 0 R');
  put(p,'   /Filter [/ASCII85Decode] >>');
  put(p,'stream');
  vString := '';
  if docTable(p).Page.GraphicsStream.exists(1) then
    for i in docTable(p).Page.GraphicsStream.first..docTable(p).page.GraphicsStream.last loop
      -- put(p, docTable(p).Page.GraphicsStream(i));
      vString := vString || docTable(p).page.graphicsStream(i)||chr(13)||chr(10);
      vLen := vLen + length(trim(docTable(p).page.GraphicsStream(i))) + 2;
    end loop;
  end if;
  vString := vString || 'BT'||chr(13)||chr(10);
  for i in docTable(p).Page.TextStream.first..docTable(p).Page.TextStream.Last loop
    vString := vString ||docTable(p).page.textStream(i)||chr(13)||chr(10);
    -- put(p, docTable(p).Page.TextStream(i));
    vLen := vLen + length(trim(docTable(p).page.TextStream(i))) + 2;
  end loop;
  vString := vString || 'ET'||chr(13) || chr(10);
  vString := base85.base85encode(vString);
  --vLen := length(vString) + 8; -- For Begintext and endtext
  vLen := length(vString);
  v := 1;
  --put(p,vString);
  
  while v <= length(vString) loop
    put(p,subStr(vString,v,50));
    v := v + 50;
    vLen := vLen + 2;
  end loop;
    
  put(p,'endstream');
  put(p,'endobj');
  -- Now write the length object
  AddxRef(p,docTable(p).Page.SizeObj#,docTable(p).Offset,'Size ' || to_char(docTable(p).Page.Page#));
  put(p, to_char(docTable(p).Page.SizeObj#)||' 0 obj');
  put(p,'  ' ||to_char(vlen - 2) );
  put(p,'endobj');
end endpageEncode;
procedure endFormXOBject( p in handle)
is
  vLen number(6) := 0;
  vLenObj# number;
  vPtr integer;
begin
  -- the main difference between pages and xobjects, when ending, aside from the
  AddxRef(p,docTable(p).page.pageObj#, docTable(p).offset,'Form Xobject '||docTable(p).page.name);
  put(p,to_char(docTable(p).Page.pageObj#)||' 0 obj');
  put(p,'<</Type /XObject');
  put(p,'  /Subtype /Form');
  put(p,'  /FormType 1');
  put(p,'  /BBox [0 0 1000 1000]');
  put(p,'  /Matrix [1 0 0 1 0 0]');
  put(p,'  /Resources << /Procset [ /PDF ] ');
  put(p,'  /Font << ' || docTable(p).Page.FontList ||' >>');
  put(p,'>>');
  
  -- calculate the length first
  if docTable(p).Page.GraphicsStream.exists(1) then
    for i in docTable(p).Page.GraphicsStream.first..docTable(p).page.GraphicsStream.last loop
      vLen := vLen + length(trim(docTable(p).page.GraphicsStream(i))) + 2;
    end loop;
  end if;
  for i in docTable(p).Page.TextStream.first..docTable(p).Page.TextStream.Last loop
    vLen := vLen + length(trim(docTable(p).page.TextStream(i))) + 2;
  end loop;
  vLen := vLen + 8; -- For Begintext and endtext
  put(p,'  /Length ' || to_char(vLen));
  put(p,'>>');
  put(p,'stream');
  if docTable(p).Page.GraphicsStream.exists(1) then
    for i in docTable(p).Page.GraphicsStream.first..docTable(p).page.GraphicsStream.last loop
      put(p, docTable(p).Page.GraphicsStream(i));
      --vLen := vLen + length(trim(docTable(p).page.GraphicsStream(i))) + 2;
    end loop;
  end if;
  put(p,'BT');
  for i in docTable(p).Page.TextStream.first..docTable(p).Page.TextStream.Last loop
    put(p, docTable(p).Page.TextStream(i));
    --vLen := vLen + length(trim(docTable(p).page.TextStream(i))) + 2;
  end loop;
  put(p,'ET');
  --vLen := vLen + 8; -- For Begintext and endtext
  put(p,'endstream');
  put(p,'endobj');
end endFOrmXObject;
procedure endPage(p in handle)
is
  vLen number(6) := 0;
  vString varchar2(1000);
begin
  -- output the three objects, and register in xref table
  AddxRef(p,docTable(p).Page.PageObj#,docTable(p).offset, 'Page ' || to_char(docTable(p).Page.Page#));
  put(p,to_char(docTable(p).Page.pageObj#)||' 0 obj');

  put(p,'<< /Type /Page');
  put(p,'   /Parent ' || to_char(docTable(p).Page.ParentObj#) || ' 0 R');
  put(p,'  /MediaBox [0 0 ' || to_char(docTable(p).PageWidth)|| ' '
    || to_Char(docTable(p).PageHeight) || ']');
  /*  
  if docTable(p).Orientation = 'Landscape' then
    put(p,'   /MediaBox [0 0 792 612]');
    docTable(p).PageHeight := 612; -- page height is in points
    docTable(p).PageWidth  := 792; -- page width is in points
    docTable(p).TopMargin  := 8.0 * 72; --  starting point. Rows are relative to top margin.
  else -- default    
    put(p,'   /MediaBox [0 0 612 792]');
  end if;
  */    
  put(p,'   /Contents ' || to_char(docTable(p).Page.StreamObj#)||' 0 R');
  put(p,'   /Resources << /ProcSet 4 0 R ');
  -- put(p,'% XObject List: ' || docTable(p).page.xObjectList );
  if length(ltrim(docTable(p).page.xObjectList)) > 0 then
    put(p,'   /XObject << ' || docTable(p).page.XobjectList||' >>');
  end if;  
  
--  if pvXObjectTable.exists(1) then
--    vString := '';
--    for i in pvXObjectTable.first .. pvXObjectTable.last loop
--      vString := vString || 
--        '/'||pvXObjectTable(i).name||' ' || to_char(pvXObjectTable(i).object#)|| ' 0 R ';
--    end loop;    
--    put(p,'  /XObject << '||vString||' >>');
--  end if;       
  put(p,'                 /Font << ' || docTable(p).Page.FontList ||' >>');
  put(p,'              >>');
  put(p,'>>');
  put(p,'endobj');
  -- now the stream
  AddxRef(p,docTable(p).page.StreamObj#,docTable(p).Offset,'Stream ' || to_char(docTable(p).Page.Page#));
  put(p,To_char(docTable(p).Page.StreamObj#) || ' 0 obj');
  put(p,'<< /Length ' || to_char(docTable(p).Page.SizeObj#)||' 0 R >>');
  put(p,'stream');
  if docTable(p).Page.GraphicsStream.exists(1) then
    for i in docTable(p).Page.GraphicsStream.first..docTable(p).page.GraphicsStream.last loop
      put(p, docTable(p).Page.GraphicsStream(i));
      vLen := vLen + length(trim(docTable(p).page.GraphicsStream(i))) + 2;
    end loop;
  end if;
  put(p,'BT');
  for i in docTable(p).Page.TextStream.first..docTable(p).Page.TextStream.Last loop
    put(p, docTable(p).Page.TextStream(i));
    vLen := vLen + length(trim(docTable(p).page.TextStream(i))) + 2;
  end loop;
  put(p,'ET');
  vLen := vLen + 8; -- For Begintext and endtext
  put(p,'endstream');
  put(p,'endobj');
  -- Now write the length object
  AddxRef(p,docTable(p).Page.SizeObj#,docTable(p).Offset,'Size ' || to_char(docTable(p).Page.Page#));
  put(p, to_char(docTable(p).Page.SizeObj#)||' 0 obj');
  put(p,'  ' ||to_char(vlen) );
  put(p,'endobj');
end endpage;
--
-- Units of measurement are points (1/72 inch), inches
-- and row/col. The latter would vary depending upon
-- the font,so use may be problematic... The default unit of measure is
-- the point. Options include 
-- r, c (row or column; interchangeable, based on current font
-- i inches
-- p points
-- When output is generated all units are converted to points, since that is
-- the only positioning unit recognized by pdf                            

-- convertunits is a handdy function that converts units from one format to
-- another.
Procedure setDefaultUnit(p in handle, pUnit in varchar2)
is
begin
  docTable(p).defaultUnit := pUnit;
end setDefaultUnit;  

Function getDefaultUnit( p in handle) return varchar2
is
begin
  return docTable(p).defaultUnit;
end getDefaultUnit;  
function convertunits(p in handle,
                      pUnits in number, pFrom varchar2, pTo varchar2) return number
is
  vPoints number(10);
  vReturn number(10,2);
begin
  if pvDebugging then
    put(p,'%convertunits: pUnits '||to_char(punits)|| ' pFrom ' || pFrom || ' pTo ' || pTo);
  end if;
  CheckMeasurementUnit(pFrom);
  CheckMeasurementUnit(pTo);
  if pFrom = 'i' then
    vPoints := 72 * pUnits;
  elsif pFrom  = 'r' then
    vPoints := pUnits * docTable(p).LineHeight;
  elsif pFrom = 'c' then
    vPoints := pUnits * docTable(p).charwidth;
  else
    vPoints := pUnits;
  end if;
  if pTo = 'i' then
    vReturn := vPoints / 72;
  elsif pTo = 'r' then
    vReturn := vPoints / docTable(p).LineHeight;
  elsif pTo = 'c' then
    vReturn := vPoints / docTable(p).CharWidth;
  else
    vReturn := vPoints;
  end if;
  return vReturn;
end convertunits;



Function getBlob(p in handle) return blob
is
begin
  return docTable(p).the_blob;
end getBlob;  


--
-- Font procedures and function
-- 
Function FindFontByKey(pFontKey in varchar2) return number
is
  vReturn number(5) := 0;
begin
  if pvFontTable.exists(1) then
    for i in pvFontTable.first..pvFontTable.last loop
      if pvFontTable(i).fontkey = pFontkey then
        vReturn := i;
        exit;
      end if;
    end loop;
  end if;
  return vReturn;
end FindFontByKey;
function getFontkey( pFontName in varchar2) return varchar2
is
  vReturn varchar2(30);
begin
  for i in pvFontTable.first..pvFontTable.last loop
    if pvFontTable(i).fontname = pFontName then
       vReturn := pvFontTable(i).fontKey;
       exit;
     end if;
  end loop;
  return vReturn;  
end getFontKey;
procedure setFontByName(p in handle,
                        pFontName in varchar2,
                        pFontSize in number)
is
begin
  setFont(p, getFontkey(pFontName),pFontSize);
end setFontByName;

procedure setFont(p in handle,pFontKey in varchar2,pFontSize in number)
is
  vPtr integer;
  vStreamPtr integer;
  vFontObj# integer;
  vString varchar2(1000);
begin
  -- First check if this font has been registered in the document
  vPtr := FindFontbyKey(pFontKey);  
  If vPtr < 1 then
    raise_application_error(-20001,'Unknown font key <'||pFontKey||'>');
  end if;
  vFontObj# := registerFont(p, pFontKey );
  if docTable(p).page.TextStream.exists(1) then
    vStreamPtr := docTable(p).page.TextStream.last + 1;
  else
    vStreamPtr := 1;
  end if;
  docTable(p).page.TextStream(vStreamPtr) := '/'
    || pvFontTable(vPtr).FontKey
    || ' ' || to_char(pFontSize)
    || ' Tf';
  -- And add to font list for resources
  vString := '/' || pFontKey
    || ' ' || to_char(vFontObj#)
    || ' 0 R';
  if docTable(p).page.fontList is null then
    docTable(p).page.fontList := vString;
  elsif instr(docTable(p).page.fontList,'/'||pFontKey||' ') = 0 then
    docTable(p).Page.fontList := docTable(p).page.fontList || ' ' || vString;
  end if;
  docTable(p).CurrentFontSize := pFontsize;
  docTable(p).CurrentFontKey := pFontKey;
end setFont;
procedure setCharWidth(p in handle, pPoints in number)
is
begin
  docTable(p).charWidth := pPoints;
end setCharWidth;  
  
--
-- Write routines
--
--@ Write
--@ because the positioning begins at the bottom right, the current row
--@ is the point value of the row subtracted from the page height( along with
--@ the top margin).
procedure write(p in handle,
                pX in number, -- horizontal / column position
                pY in number, -- vertical / row position
                pString in varchar2, -- text to display
                pAlign in varchar2 default 'l', -- left, center, right
                pUnit in varchar2 default null) -- point,inch, row/col
is
  vUnit varchar2(1);
  vString varchar2(2000) := pString;
  vLength integer;
begin
  vUnit := resolveUnit(p,pUnit,'r');
  vLength := strLength(docTable(p).CurrentFontKey, docTable(p).CurrentFontSize, pString);
  docTable(p).currentRow := ConvertUnits(p,pY,vUnit,'p');
  -- dbms_output.put_line('pY of ' || to_char(py)||' unit ' || vUnit || ' saved as ' || to_char(docTable(p).CurrentRow));
  vUnit := resolveUnit(p,pUnit,'c');
  docTable(p).currentCol := ConvertUnits(p,pX,vUnit,'p');
  --  put('% col converted to ' || to_char(pvCol));
  -- now how to adjust for right or centered alignment?
  --  12345
  --   ab
  if pAlign = 'c' then
    docTable(p).currentCol := docTable(p).currentCol - (vLength / 2);
  elsif pALign = 'r' then
    -- docTable(p).currentCol := docTable(p).currentCol - ( docTable(p).charwidth * (length(pString) - 1)) ;
    docTable(p).currentCol := docTable(p).currentCol - vLength;
  end if;
  if instr(vString,'(') > 0 then
    vString := replace(vString,'(','\(');
  end if;
  if instr(vString,')') > 0 then
    vString := replace(vString,')','\)');
  end if;

  docTable(p).Page.TextStream( docTable(p).page.TextStream.Last + 1) :=
   to_char(docTable(p).LeftMargin + docTable(p).currentCol)||' '||to_char((docTable(p).PageHeight - docTable(p).TopMargin) - docTable(p).currentRow)||' '
       || ' Td';
  docTable(p).Page.TextStream( docTable(p).page.TextStream.last + 1) :=
        '('||vString||') '
       || 'Tj';
  docTable(p).Page.TextStream( docTable(p).Page.TextStream.last + 1) := '1 0 0 1 0 0 Tm';
  docTable(p).currentCol := docTable(p).currentCol + vLength;

end write;
procedure writeout(p in handle, pString in varchar2) is
begin
  Write(p,docTable(p).currentCol,docTable(p).currentRow,pString,null,'p');
end WriteOut;                    
procedure WriteNext(p in handle,
                pX in number, -- horizontal / column position
                pString in varchar2, -- text to display
                pAlign in varchar2 default 'l', -- left, center, right
                pUnit in varchar2 default null) -- point,inch, row/col
is
  vUnit varchar2(1);
begin
  -- currentRow is stored in points, so we need to convert these units
  -- to points
  vUnit := resolveUnit(p,pUnit,'c');
  Write(p, ConvertUnits(p,px,vUnit,'p'), docTable(p).CurrentRow + docTable(p).LineHeight, pString, pAlign,'p');
end writeNext;  
procedure WriteCol(p in handle,
                pX in number, -- horizontal / column position
                pString in varchar2, -- text to display
                pAlign in varchar2 default 'l', -- left, center, right
                pUnit in varchar2 default null) -- point,inch, row/col

is
  vUnit varchar2(1);
begin
  vUnit := resolveUnit(p,pUnit,'c');
  Write(p, ConvertUnits(p,px,vUnit,'p'),docTable(p).CurrentRow,pString, pAlign, 'p');
End WriteCol;
procedure writeCenteredInLine(p in handle,
          pY in number, -- the row
          pString in varchar2,
          pUnit in varchar2 default null)
is
  vUnit varchar2(1);
  vCol number(5);
begin
  vUnit := resolveUnit(p,pUnit,'r');
  -- what is the column position of the center of the line?
  vCol := (docTable(p).pageWidth - docTable(p).LeftMargin) / 2;
  write(p,vCol,convertUnits(p,pY,vUnit,'p'),pString,'c','p');
end writeCenteredInLine;    
function getCurrentRow(p in handle, pUnit in varchar2 default null) return number
is
  vUnit varchar2(1);
  vReturn number(10,2);
begin
  vUnit := resolveUnit(p,pUnit,'r');
  vReturn := ConvertUnits(p,docTable(p).CurrentRow,'p',vUnit);
  return vReturn;
end getCurrentRow;
function getCurrentCol(p in handle, pUnit in varchar2 default null) return number
is
  vUnit varchar2(1);
  vReturn number(10,2);  
begin
  vUnit := resolveUnit(p,pUnit,'c');
  vReturn := ConvertUnits(p,docTable(p).CurrentCol,'p',vUnit);
  return vReturn;
end getCurrentCol;          
procedure setCurrentRow(p in handle, pValue in number, pUnit in varchar2 default null)
is
  vUnit varchar2(1);
begin
  vUnit := resolveUnit(p,pUnit,'r');
  docTable(p).CurrentRow := convertUnits(p,pValue,pUnit,'p');
end setCurrentRow;
procedure setCurrentCol(p in handle, pValue in number, pUnit in varchar2 default null)
is
  vUnit varchar2(1);
begin
  vUnit := resolveUnit(p,pUnit,'c');
  docTable(p).CurrentCol := convertUnits(p,pValue,vUnit,'p');
end setCurrentCol;              
                
function nextRow(p in handle,pUnit in varchar2 default null) return number
is
  vUnit varchar2(1);
  vReturn number;
begin
  vUnit := resolveUnit(p,pUnit,'r');
  vReturn := ConvertUnits(p,docTable(p).CurrentRow + docTable(p).LineHeight,'p',vUnit);
  return vReturn;
end;      
function getBottomRow(p in handle,punit in varchar2 default null) return number
is
  vUnit varchar2(1);
  vReturn number;
begin
  -- Positioning begins at the bottom.  So get the count of rows available
  -- This will be the bottomw row in 'r' units. Convert as necessary
  vReturn := (docTable(p).pageHeight - (docTable(p).TopMargin + docTable(p).BottomMargin)) / docTable(p).LineHeight;
  vUnit := resolveUnit(p,pUnit,'r');
  vReturn := ConvertUnits(p,vReturn,'r',vUnit);
  return vReturn;    
end GetbottomRow;      
function getFreeRows( p in handle) return number
is
  vReturn number(10,2);
begin
  vReturn := (getBottomRow(p, 'p') - getCurrentRow(p,'p')) / getLineHeight(p,'p');
  return vReturn;
end getFreeRows;        
procedure setTarget(p in handle, pTarget in varchar2)
is
begin
  docTable(p).target := pTarget;
end setTarget;  
function getTarget(p in handle) return varchar2
is
begin
  return docTable(p).Target;
end getTarget;  
procedure setPageNumber(p in handle, pNumber in number)
is
begin
  docTable(p).CurrentPage# := pNumber;
end setPageNumber;  
function getPageNumber(p in handle) return number
is
begin
  return docTable(p).Currentpage#;
end getpageNumber;  

  


procedure setDebugging ( value in boolean)
is
begin
  pvDebugging := value;
end setDebugging;  
    
Procedure SetPageSize(p in handle,
                      pHeight in number ,
                      pWidth in number ,
                      pUnits in varchar2 default null)
is
  vUnits varchar2(1);
begin
  vUnits := resolveUnit(p,pUnits,'r');
  docTable(p).PageHeight := ConvertUnits(p,pHeight,vUnits,'p');
  vUnits := resolveUnit(p,pUnits,'c');
  docTable(p).PageWidth := ConvertUnits(p,pWidth,vUnits,'p');

    
end;
function getLeftMargin( p in handle, pUnit in varchar2 default null)
  return number
is
  vUnit varchar2(1);
  vMargin number;
begin
  vUnit := ResolveUnit(p,pUnit,'c');
  vMargin := ConvertUnits(p, docTable(p).LeftMargin,'p',vUnit);
  return vMargin;
end getLeftMargin;  
procedure setLeftMargin( p in handle,pMargin in number,
                         pUnit in varchar2 default null)
is
  vUnit varchar2(1);
begin
  vUnit := ResolveUnit( p, pUnit,'c');
  docTable(p).leftMargin := convertUnits(p,pMargin,vUnit,'p');
end setLeftMargin;      
procedure setRightMargin( p in handle,
                          pMargin in number,
                          pUnit in varchar2 default null)
is
  vUnit varchar2(1);
begin
  vUnit := resolveUnit(p,pUnit,'c');
  docTable(p).RightMargin := convertUnits(p,pMargin,vUnit,'p');
end setRightMargin;
function getRightMargin( p in handle,
                        pUnit in varchar2 default null)
                        return number
is
  vUnit varchar2(1);
  vMargin number;
begin
  vUnit := resolveUnit(p,pUnit,'c');
  vMargin := ConvertUnits(p,docTable(p).rightMargin,'p',vUnit);
  return vMargin;
end getRightMargin;  
function getRightColumn(p in handle,pUnit in varchar2 default null) return number
is
  vReturn number;
  vPoints number;
  vUnit varchar2(1);
begin
  vUnit := resolveUnit(p,pUnit,'c');
  vPoints := docTable(p).pageWidth - (docTable(p).leftMargin + docTable(p).rightMargin);
  vReturn := convertUnits(p,vPoints,'p',vUnit);
  return vReturn;
end getRightColumn;  
      
procedure setMargins(p in handle, pTop in number, pLeft in number,
  pBottom in number, pRight in number, pUnit in varchar2 default null)
is
begin
  setTopMargin(p,pTop,pUnit);
  setLeftMargin(p,pLeft,pUnit);
  setBottomMargin(p,pBottom,pUnit);
  setRightMargin(p,pRight,pUnit);
end setMargins;

procedure setTopMargin( p in handle,
                        pMargin in number,
                        pUnit in varchar2 default null) 
is
  vUnit varchar2(1);
begin
  vUnit := resolveUnit(p,pUnit,'r');
  docTable(p).topMargin := convertUnits(p,pMargin,vUnit,'p');
end setTopMargin;
function getTopMargin( p in handle,
                       pUnit in varchar2)
                       return number
is
  vUnit varchar2(1);
  vMargin number;
begin
  vUnit := resolveUnit(p, pUnit,'r');
  vMargin := convertUnits(p,docTable(p).Topmargin,'p',vUnit);
  return vMargin;
end getTopMargin;  
                           
procedure setLineHeight(p in handle,
  pHeight in number, 
  pUnit in varchar2 default null)
is
  vUnit varchar2(1);
begin
  vUnit := resolveUnit(p,pUnit,'r');
  docTable(p).LineHeight := convertUnits(p,pHeight,vUnit,'p');
end setLineHeight;      
function getLineHeight(p in handle, pUnit in varchar2) return number
is
  vUnit varchar2(1);
  vHeight number;
begin
  vUnit := resolveUnit(p,pUnit,'r');
  dbms_output.put_line('resolved unit: ' || vUnit);
  dbms_output.put_line('LineHeight in p' || to_char(docTable(p).lineHeight));
  vHeight := convertUnits(p,docTable(p).LineHeight,'p',vUnit);
  dbms_output.put_line('Height ' || to_char(vHeight));
  return vHeight;
end getLineHeight;    
procedure setBottomMargin( p in handle, pMargin in number, pUnit in varchar2 default null)
is
  vUnit varchar2(1);
begin
  vUnit := resolveUnit(p, pUnit,'r');
  docTable(p).BottomMargin := convertUnits(p, pMargin,vUnit,'p');
end setBottomMargin;     
function getBottomMargin( p in handle,pUnit in varchar2) return number
is
  vUnit varchar2(1);
  vMargin number;
begin
  vUnit := resolveUnit(p,pUnit,'r');
  vMargin := convertUnits(p, docTable(p).Bottommargin,'p',vUnit);
  return vMargin;
end getBottomMargin;  
    
                                

procedure Shade1(p in handle,
                pX1 in number,
                pY1 in number,
                pX2 in number,
                pY2 in number,
                pScale in number default null,
                pUnit in varchar2 default null)
is
  vptr integer;
  vX1  number(5);
  vX2  number(5);
  vY1  number(5);
  vY2  number(5);
  vUnit  varchar2(1);
begin
  vUnit := resolveUnit(p,pUnit,'r');
  vY1 := docTable(p).pageHeight - (docTable(p).Topmargin + ConvertUnits(p,pY1,vUnit,'p'));
  vY2 := docTable(p).pageHeight - (docTable(p).TopMargin + ConvertUnits(p,PY2,vUnit,'p'));
  vUnit := resolveUnit(p,pUnit,'c');
  vX1 := docTable(p).leftMargin + ConvertUnits(p,pX1,vUnit,'p');
  vX2 := docTable(p).leftMargin + ConvertUnits(p,pX2,vUnit,'p');
    
  if docTable(p).Page.GraphicsStream.exists(1) then
    vptr := docTable(p).page.GraphicsStream.last + 1;
  else
    vPtr := 1;
  end if;
  docTable(p).Page.GraphicsStream(vPtr) := to_char( nvl(pScale,0.9),'990.00')
    || ' g';
    
  docTable(p).Page.GraphicsStream(vPtr + 1) :=
    to_char(vX1)|| ' ' || to_char(vY1) || ' ' ||
      to_char(vX2 - vX1 ) || ' ' || to_char(vY2 -  vY1) || ' re';
  docTable(p).Page.GraphicsStream(vPtr + 2) := 'f 0 g';
end shade1;


                        
procedure Shade(p in handle,
                pX1 in number,
                pY1 in number,
                pX2 in number,
                pY2 in number,
                pScale in number default null,
                pUnit in varchar2 default null)
is
  vptr integer;
  vX1  number(5);
  vX2  number(5);
  vY1  number(5);
  vY2  number(5);
  vUnit  varchar2(1);
begin
  vUnit := resolveUnit(p,pUnit,'r');
  vY1 := ConvertUnits(p,pY1,vUnit,'p');
  vY2 := ConvertUnits(p,PY2,vUnit,'p');
  vUnit := resolveUnit(p,pUnit,'c');
  vX1 := ConvertUnits(p,pX1,vUnit,'p');
  vX2 := ConvertUnits(p,pX2,vUnit,'p');
    
  if docTable(p).Page.GraphicsStream.exists(1) then
    vptr := docTable(p).page.GraphicsStream.last + 1;
  else
    vPtr := 1;
  end if;
  docTable(p).Page.GraphicsStream(vPtr) := to_char( nvl(pScale,0.9),'990.00')
    || ' g';
    
  docTable(p).Page.GraphicsStream(vPtr + 1) :=
    to_char(docTable(p).LeftMargin + vX1)|| ' ' || to_char(( docTable(p).PageHeight - docTable(p).TopMargin) - vY1) || ' ' ||
      to_char(vX2 - vX1 ) || ' ' || to_char(vY2 -  vY1) || ' re';
  docTable(p).Page.GraphicsStream(vPtr + 2) := 'f 0 g';
end shade;
procedure GreyBar( p in handle,
                   pY in number, pUnit in varchar2 default null)
is
  -- pUnit must resolve to a "row" which is then shaded to a height, more
  -- or less, of docTable(p).LineHeight
  vUnit varchar2(1);
  vRow number;
begin
  vUnit := resolveUnit(p,pUnit,'r');
  vRow := convertUnits(p,pY,vUnit,'r');
  shade(p,1,vRow + 0.1,getLineWidth(p),vRow + 0.9);
end GreyBar;
procedure pageBorder(p in handle)
is
begin
  drawLine(p,0,0,getLineWidth(p,'p') + 5,0,'p'); -- across top of page
  drawLine(p,0,getBottomRow(p,'p')+5,getLineWidth(p,'p')+5,
    getBottomRow(p,'p')+5,'p');     -- across bottom
  drawLine(p,0,0,0,getBottomRow(p,'p')+5,'p');   -- left side
  drawLine(p,getLineWidth(p,'p')+5,0,getLineWidth(p,'p')+5,getBottomRow(p,'p')+5,'p');
end pageBorder;
procedure lineAcrossPage(p in handle,pY in number,pUnit in varchar2 default null)
is
  vUnit varchar2(1);
  vRow number;
begin
  vUnit := resolveUnit(p,pUnit,'r');
  vRow := convertUnits(p,pY,vUnit,'p');
  drawLine(p,0,vRow,getLineWidth(p,'p')+5,vRow,'p');
end lineAcrossPage;                              
Procedure Rectangle(p in handle,
                    pX in number,
					pY in number,
					pWidth in number,
					pHeight in number,
					pUnit in varchar2 default null,
                    pLineWidth in number default null)
is
  vHeight  number(6);
  vWidth  number(6);
  vUnit varchar2(1);
  vX number(6);
  vY number(6);
  vPtr integer;
begin
  drawLine(p,pX,pY,pX + pWidth, pY,pUnit,pLineWidth); -- top line
  drawLine(p,pX,pY + pHeight,pX + pWidth, pY + pHeight,pUnit,pLineWidth); -- bottom line
  drawLine(p,pX,pY,pX, pY + pHeight,pUnit,pLineWidth); -- left side
  drawLine(p,pX + pWidth,pY,pX + pWidth, pY + pHeight,pUnit,pLineWidth);  -- right side

  
/*
  if pUnit = 'c' then
    vUnit := 'r';
  else
    vUnit := pUnit;
  end if;
  vHeight := ConvertUnits(p,pHeight,vUnit,'p');
  vY := ConvertUnits(p,pY,vUnit,'p');
  if pUnit = 'r' then
    vUnit := 'c';
  else
    vUnit := pUnit;
  end if;
  vWidth := ConvertUnits(p,pWidth, vUnit,'p');
  vX := ConvertUnits(p,pX,vUnit,'p');
  if docTable(p).Page.GraphicsStream.exists(1) then
    vPtr := docTable(p).Page.GraphicsStream.last + 1;
  else
    vPtr := 1;
  end if;
  docTable(p).Page.GraphicsStream(vPtr) :=
    to_char(docTable(p).LeftMargin + vX) || ' ' ||
	to_char(( docTable(p).PageHeight - docTable(p).TopMargin) - Vy)  || ' ' ||
	to_Char(vWidth) || ' ' ||
	to_char(vHeight) || ' re';
*/    
End Rectangle;
procedure addGraphic(p in handle,pText in varchar2)
is
  vPtr integer;
begin
  if docTable(p).Page.GraphicsStream.exists(1) then
    vptr := docTable(p).page.GraphicsStream.last + 1;
  else
    vPtr := 1;
  end if;
  docTable(p).page.graphicsStream(vPtr) := pText;
end addGraphic; 
-- and ellipse is drawn with 4 bezier curves.
-- see http://www.codeguru.com/gdi/ellipse.shtml
procedure ellipse(p in handle,
                  pX in number, pY in number,
                  pRadiusX in number, pRadiusY in number,
                  pUnit in varchar2 default null,
                  pLinewidth in number default null)
is
  type coord_r is record (x integer, y integer);
  type coord_t is table of coord_r index by binary_integer;
  vXy coord_t;
  vRadius coord_r;
  vCenter coord_r;
  vOffset coord_r;
  vMagic Number(20,15) := 0.2761423749154;   
  vRowUnit varchar2(1);
  vColUnit varchar2(1);
  vUnit varchar2(1);
  
  
begin
  addGraphic(p,'q');
  if pLineWidth is not null then
    addGraphic(p, to_char(pLineWidth) || ' w');
  end if;
  addGraphic(p,'1 i');
  vUnit := nvl(pUnit,docTable(p).defaultUnit);
  if vUnit in ( 'r','c') then
    vRowUnit := 'r';
	vColUnit := 'c';
  else
    vRowUnit := vUnit;
	vColUnit := vUnit;
  end if;
  vCenter.x := convertUnits(p,pX,vColUnit,'p') + docTable(p).LeftMargin;
  vCenter.y := (docTable(p).PageHeight - docTable(p).TopMargin) -  convertUnits(p,pY,vRowUnit,'p');
  vRadius.x := convertUnits(p,pRadiusX,vColUnit,'p');
  vRadius.y := convertUnits(p,pRadiusY,vRowUnit,'p');
  -- we now have the center point, vX, vY
  -- the horizontal radius vX, and the vertical radius vY
  /*  
                   //                        /
                   //        2___3___4       /
                   //     1             5    /
                   //     |             |    /
                   //     |             |    /
                   //     0,12          6    /
                   //     |             |    /
                   //     |             |    /
                   //    11             7    /
                   //       10___9___8       /
                   //                        /
                   //------------------------*
  */  
  vOffset.x := 2 * vRadius.x * vMagic;
  vOffset.y := 2 * vRadius.y * vMagic;
  
  vXy(0).x := vCenter.x - vRadius.x;
  vXy(1).x := vXy(0).x;
  vXy(11).x := vXy(0).x;
  vXy(12).x := vXy(0).x;
  vXy(5).x := vCenter.x + vRadius.x;
  vXy(6).x := vXy(5).x;
  vXy(7).x := vXy(5).x;
  vXy(2).x := vCenter.x - vOffset.x;
  vXy(10).x := vXy(2).x;
  vXy(3).x := vCenter.x;
  vXy(9).x := vCenter.x;
  vXy(4).x := vCenter.x + vOffset.x;
  vXy(8).x := vXy(4).x;
  
  vXy(2).y := vCenter.y + vRadius.y;
  vXy(3).y := vXy(2).y;
  vXy(4).y := vXy(2).y;
  
  vXy(8).y := vCenter.y - vRadius.y;
  vXy(9).y := vXy(8).y;
  vXy(10).y := vXy(8).y;
  
  vXy(0).y := vCenter.y;
  vXy(1).y := vCenter.y + vOffset.y;
  vXy(11).y := vCenter.y - vOffset.y;
  vXy(12).y := vCenter.y;
  
  vXy(5).y := vCenter.y + vOffset.y;
  vXy(6).y := vCenter.y;
  vXy(7).y := vCenter.y - vOffset.y;
  
  
  -- move to the left point.
  addGraphic(p, to_char( vXy(0).x) || ' '||to_char(vXy(0).y)||' m');
  -- draw the first arc with points 1, 2, 3
  addGraphic(p, to_char(vXy(1).x)||' '|| to_char(vXy(1).y)||' ' ||
                   to_char(vXy(2).x)||' '|| to_char(vXy(2).y)||' ' ||
                   to_char(vXy(3).x)||' '|| to_char(vXy(3).y)||' c');
  -- and the second with points 4, 5, 6                   
  addGraphic(p, to_char(vXy(4).x)|| ' '||to_char(vXy(4).y)||' ' ||
                   to_char(vXy(5).x)|| ' '||to_char(vXy(5).y)||' ' ||
                   to_char(vXy(6).x)|| ' '||to_char(vXy(6).y)||' c');
  -- and the third with points 7, 8, 9
  addGraphic(p, to_char(vXy(7).x)|| ' '||to_char(vXy(7).y)||' ' ||
                   to_char(vXy(8).x)|| ' '||to_char(vXy(8).y)||' ' ||
                   to_char(vXy(9).x)|| ' '||to_char(vXy(9).y)||' c');
  -- and the fourth with points 10, 11, 12
  addGraphic(p, to_char(vXy(10).x)|| ' '||to_char(vXy(10).y)||' ' ||
                   to_char(vXy(11).x)|| ' '||to_char(vXy(11).y)||' ' ||
                   to_char(vXy(12).x)|| ' '||to_char(vXy(12).y)||' c');
  addGraphic(p,'S Q');
end ellipse;
                  
procedure drawline(p in handle,
                   pX1 in number,pY1 in number, pX2 in number, pY2 in number,
                   pUnit in varchar2 default null,
                   pWidth in number default null)
is
  vptr integer;
  vRowUnit varchar2(1);
  vColUnit varchar2(1);
  vUnit varchar2(1);
begin
  if docTable(p).Page.GraphicsStream.exists(1) then
    vptr := docTable(p).page.GraphicsStream.last + 1;
  else
    vPtr := 1;
  end if;
  if pWidth is not null then
    docTable(p).Page.GraphicsStream(vPtr) := to_char(pWidth) || ' w';
    vPtr := vPtr + 1;
  end if;
  vUnit := nvl(pUnit,docTable(p).defaultUnit);
  if vUnit in ( 'r','c') then
    vRowUnit := 'r';
	vColUnit := 'c';
  else
    vRowUnit := vUnit;
	vColUnit := vUnit;
  end if;

  docTable(p).Page.GraphicsStream(vPtr) :=
    to_char(docTable(p).leftmargin + ConvertUnits(p,pX1,vColUnit,'p')) || ' ' ||
    to_char(( docTable(p).PageHeight - docTable(p).topmargin) - ConvertUnits(p,pY1,vRowUnit,'p')) || ' ' ||
    ' m ' ||
    to_char(docTable(p).leftmargin + convertUnits(p,pX2,vColUnit,'p')) || ' ' ||
    to_char((docTable(p).PageHeight - docTable(p).topmargin) - convertUnits(p,pY2,vRowUnit,'p')) || ' ' ||
    ' l s';


end drawline;

function strLength(pFontKey in varchar2, pFontSize in number, pString in varchar2)
  return number -- returns width of string for specified font, in points
is
  vReturn integer;
  cursor fontCur(cpFontKey varchar2, cpCharacter char) is
    select   width from pdf_font_metrics
    where pdf_key = upper(pFontKey)
    and char# = ascii(cpCharacter);
  fontRec fontCur%rowtype;    
begin
  vReturn := 0;
  dbms_output.put_line('Checking ['||pString||']');
  if pString is not null then
    for i in 1..length(pString) loop
      --dbms_output.put_line(to_char(i)||':'||substr(pstring,i,1));
      open fontCur(pFontKey, substr(pString,i,1));
      fetch fontCur into fontRec;
      if fontCur%notfound then
        dbms_output.put_line('Did not find character');
      end if;  
      --dbms_output.put_line('Raw Width ' || fontRec.width);
      vReturn := vReturn + (fontRec.width * pFontSize);
      --dbms_output.put_line('Raw Total is now ' || vReturn);
      close fontCur;
    end loop;
  end if;  
  return vReturn/1000;    
end strLength;  
procedure setTextState(p in handle,
                       pCharSpace in number default 0,
                       pwordSpace in number default 0,
                       pScale in number default 100,
                       pLeading in number default 0,
                       pRender in number default 0,
                       pRise in number default 0)
is
begin
  docTable(p).Page.TextStream( docTable(p).page.TextStream.Last + 1) :=
    to_char(pCharSpace)||' Tc '
    || to_char(pwordSpace)|| ' Tw '
    || to_char(pScale)|| ' Tz '
    || to_char(pLeading)|| ' TL '
    || to_char(pRender)|| ' Tr '
    || to_char(pRise) || ' Ts';
  
end setTextState;                                    
procedure setGrayScale(p in handle,pScale in number default 0)
is
begin
  --docTable(p).Page.TextStream( docTable(p).page.TextStream.Last + 1) := to_char(pScale)|| ' G';
  docTable(p).Page.TextStream( docTable(p).page.TextStream.Last + 1) := to_char(pScale,'990.99')|| ' g';

end setGrayScale;
procedure waterMark(p in handle, pText in varchar2)
is
  vSaveFontSize number;
  vSaveFontKey varchar2(10);
begin
  setgrayScale(p,0.80);
  vSaveFontsize := docTable(p).currentfontsize;
  vSaveFontKey := docTable(p).currentFontKey;
  setFont(p,'F3I',40);
  writeCenteredInLine(p,10,pText,'r');
  setFont(p,vSaveFontKey,vSaveFontSize);
  setGrayScale(p,0);
end waterMark;
/*
procedure defineJpgXOjbect(p in out nocopy document,
                               pImage in blob,
                               pName in varchar2,
                               pWidth in number,
                               pHeight in number,
                               pBitsPer in number,
                               pDevice in varchar2 default 'DeviceGray',
                               pImageLib in varchar2 default 'ImageB'
                               )
is
  vObject number;
  vObjLen number; 
  vRaw raw(40);
  vRead integer;
  vString varchar2(80);
  vLength integer := 0;
  vOffset integer := 0;
  vTotalLength integer;
  vPtr integer;
begin
  vObject := nextObj#(p);
  vObjLen := nextObj#(p);
  AddxRef(p,vObject,docTable(p).offset, 'Image ' || pName);
  put(p,to_char(vObject)||' 0 obj');
  put(p,'<< /Type /XObject /Subtype /Image');
  put(p,'   /Width ' || to_char(pWidth)||' /Height ' || to_char(pHeight));
  put(p,'   /ColorSpace /'||pDevice);
  put(p,'   /Name /'||pName);
  put(p,'   /BitsPerComponent ' || to_char(pBitsPer));
  put(p,'   /Length '|| to_char(vObjLen)|| ' 0 R ');
  put(p,'   /Filter [/ASCIIHexDecode /DCTDecode] >>');
  -- now convert the input to  ascii characters
  vRead := 40;
  vTotalLength := dbms_lob.getLength(pImage);
  vOffset := 1;
  put(p,'stream');
  while vOffset <= vTotalLength loop
    dbms_lob.read(pImage,vRead,vOffset,vRaw);
    -- convert this raw to hex characters
    vString := numbers.binToHex( utl_raw.cast_to_varchar2(vRaw) );    
    vOffset := vOffset + vRead;
    if vOffset > vTotalLength then
      vString := vString||'>';
    end if;  
    vLength := vLength + length(vString) + 2;
    
    put(p,vString);
  end loop;
  put(p,'endstream');
  put(p,'endobj');
  -- Now write the length object

  AddxRef(p,vObjLen, docTable(p).offset,'image size');
  put(p, to_char(vObjLen)||' 0 obj');
  put(p,'  ' ||to_char(vLength) );
  put(p,'endobj');
  
  if pvXObjectTable.exists(1) then
    vPtr := pvXObjectTable.last + 1;
  else
    vPtr := 1;
  end if;
  pvXObjectTable(vPtr).name := pName;
  pvXObjectTable(vPtr).object# := vObject;
  pvXObjectTable(vPtr).width := pWidth;
  pvXObjectTable(vPtr).height := pHeight;
  pvXObjectTable(vPtr).device := pDevice;
  pvXObjectTable(vPtr).imageLib := pImageLib;        
end;
*/
procedure defineImageXObject( p in handle,
                              pImage in blob,                   
                              pName in varchar2,              -- Im1
                              pWidth in number,
                              pHeight in number,
                              pBitsPerComponent in number,    -- 8 | 1
                              pColorSpace in varchar2 default null,  -- null | DeviceRGB
                              pImageMask in varchar2 default null,   -- null | true
                              pImageLib in varchar2 default null, -- null, ImageB, ImageC
                              pFilter in varchar2 default null    -- DCTDecode if jpeg                              
                              )
is
  vObject number;
  vObjLen number; 
  vRaw raw(40);
  vRead integer;
  vString varchar2(80);
  vLength integer := 0;
  vOffset integer := 0;
  vTotalLength integer;
  vPtr integer;
  
begin
  vObject := nextObj#(p);
  vObjLen := nextObj#(p);
  AddxRef(p,vObject,docTable(p).offset, 'Image ' || pName);
  put(p,to_char(vObject)||' 0 obj');
  put(p,'<< /Type /XObject /Subtype /Image');
  put(p,'   /Width ' || to_char(pWidth)||' /Height ' || to_char(pHeight));
  if pColorSpace is not null then
    put(p,'   /ColorSpace /'||pColorSpace);
  end if;
  if pImageMask is not null then
    put(p,'   /ImageMask ' || pImageMask);
  end if;    
  put(p,'   /Name /'||pName);
  put(p,'   /BitsPerComponent ' || to_char(pBitsPerComponent));
  put(p,'   /Length '|| to_char(vObjLen)|| ' 0 R ');
  if pFilter is not null then
    put(p,'   /Filter [/ASCIIHexDecode /'||pFilter||'] >>');
  else
    put(p,'  /Filter /ASCIIHexDecode >>');
  end if;    
  -- now convert the input to  ascii characters
  vRead := 40;
  vTotalLength := dbms_lob.getLength(pImage);
  vOffset := 1;
  put(p,'stream');
  while vOffset <= vTotalLength loop
    dbms_lob.read(pImage,vRead,vOffset,vRaw);
    -- convert this raw to hex characters
    vString := rawToHex( vRaw );
    vOffset := vOffset + vRead;
    if vOffset > vTotalLength then
      vString := vString||'>';
    end if;  
    vLength := vLength + length(vString) + 2;
    
    put(p,vString);
  end loop;
  put(p,'endstream');
  put(p,'endobj');
  -- Now write the length object

  AddxRef(p,vObjLen, docTable(p).offset,'image size');
  put(p, to_char(vObjLen)||' 0 obj');
  put(p,'  ' ||to_char(vLength) );
  put(p,'endobj');
  
  if pvXObjectTable.exists(1) then
    vPtr := pvXObjectTable.last + 1;
  else
    vPtr := 1;
  end if;
  pvXObjectTable(vPtr).name := pName;
  pvXObjectTable(vPtr).object# := vObject;
  pvXObjectTable(vPtr).width := pWidth;
  pvXObjectTable(vPtr).height := pHeight;
  pvXObjectTable(vPtr).device := pColorSpace;
  pvXObjectTable(vPtr).imageLib := pImageLib;        
  pvXObjectTable(vPtr).imageMask := pImageMask;
end defineImageXObject;                                                     

function findImage(p in handle, pName in varchar2) return number
is
  vPtr integer;
begin
  if pvXObjectTable.exists(1) then
    for i in pvXObjectTable.first .. pvXObjectTable.last loop
      if pvXObjectTable(i).name = pName then
        vPtr := i;
        exit;
      end if;  
    end loop;
  end if;
  if vPtr is null then
    raise_application_error(-20001,'Image ' || pName || ' not found');
  end if;  
  return vPtr;
end findImage;
procedure showForm(p in handle,
                   pName in varchar2)
is
  vPtr integer;
  vI integer;
begin
  vI := findImage(p,pName);
  if docTable(p).Page.GraphicsStream.exists(1) then
    vptr := docTable(p).page.GraphicsStream.last + 1;
  else
    vPtr := 1;
  end if;
  docTable(p).Page.GraphicsStream(vPtr) := '0   0   0   0   500 500  /'||pName||' Do  ';
  
  if (instr(docTable(p).page.xobjectList,pName) = 0) or (docTable(p).page.xObjectList is null) then
    docTable(p).page.xobjectList := docTable(p).page.xobjectList
      || ' /'||pName||' ' || to_char( pvXObjectTable(vI).object# )|| ' 0 R ';
  end if;       
  
end showForm;                       
procedure showImage(p in handle,
                    pName in varchar2,
                    pX in number, pY in number, pUnit in varchar2 default null,
                    pScaleX in number default null, pScaleY in number default null,
                    pSkewX in number default 0, pSkewY in number default 0,
                    pGrayScale in number default 0)                               
is
  vPtr integer;
  vLine varchar2(100);
  vX number;
  vY number;
  vImage number;
  vUnit varchar2(1);
  vScaleX number;
  vScaleY number;
begin
  vImage := findImage(p,pName);
  vUnit := resolveUnit(p,pUnit,'r');
  vX := convertUnits(p,pX,vUnit,'p') + docTable(p).LeftMargin;
  vUnit := resolveUnit(p,pUnit,'c');
  vY := convertUnits(p,pY,vUnit,'p');
  vY := docTable(p).PageHeight - (docTable(p).TopMargin + Vy);
  vScaleX := nvl(pScaleX, pvXObjectTable(vImage).Width);
  vScaleY := nvl(pScaleY, pvXObjectTable(vImage).Height);
  
  if docTable(p).Page.GraphicsStream.exists(1) then
    vptr := docTable(p).page.GraphicsStream.last + 1;
  else
    vPtr := 1;
  end if;
  vLine := 'q ' || to_char(pGrayScale,'990.99')|| ' g ' ||
    to_char(vScaleX) || '   ' ||
    to_char(nvl(pSkewX,0))||'   ' ||
    to_char(nvl(pSkewY,0))||'   ' ||
    to_char(vScaleY)||'   ' ||
    to_char(vX)||'   ' || to_char(vY)||' cm /' ||
    pName||' Do Q';
  docTable(p).Page.GraphicsStream(vPtr) := vLine;
  -- add to th elist of referenced xobjects for this page if not already on the list
  if (instr(docTable(p).page.xobjectList,pName) = 0) or (docTable(p).page.xObjectList is null) then
    docTable(p).page.xobjectList := docTable(p).page.xobjectList
      || ' /'||pName||' ' || to_char( pvXObjectTable(vImage).object# )|| ' 0 R ';
  end if;       
end showImage;                                            
-- Experimental code for imbedding the palatino-roman fonts
procedure imbedPalatino(p in handle) is
  vDescriptor number;
  vFont number;
  vptr number;
begin
  -- start with Palatino-Roman
  vDescriptor := nextObj#(p);
  addXRef(p,vDescriptor,docTable(p).offset, 'Descriptor');
  put(p,to_char(vDescriptor)||' 0 obj');
  put(p,'<<');
  put(p,'/Type /FontDescriptor');
  put(p,'/Ascent 733');
  put(p,'/CapHeight 692');
  put(p,'/Descent -281');
  put(p,'/Flags 34');
  put(p,'/FontBBox [-166 -283 1021 927]');
  put(p,'/FontName /Palatino-Roman');
  put(p,'/ItalicAngle 0');
  put(p,'/StemV 84');
  put(p,'/XHeight 469');
  put(p,'/StemH 84');
  put(p,'>>');
  put(p,'endobj');
  -- and now the font itself
  vFont := nextObj#(p);
  addXref(p,vFont,docTable(p).offset,'imbedded font');
  vPtr := nvl( docTable(p).fontkeyList.last ,0) + 1;
  docTable(p).fontKeyList(vPtr) := 'Palatino-Roman';
  docTable(p).fontObj#List(vPtr) := vFont;
  put(p, to_char(vFont)||' 0 obj');
  put(p,'<<');
  put(p,'/Type /Font');
  put(p,'/Subtype /Type1');
  put(p,'/FirstChar 32');
  put(p,'/LastChar 151');
  put(p,'/Widths [250 278 371 500 500 840 778 208 333 333 389 606 250 333 250 606');
  put(p,'500 500 500 500 500 500 500 500 500 500 250 250 606 606 606 444');
  put(p,'747 778 611 709 774 611 556 763 832 337 333 726 611 946 831 786');
  put(p,'604 786 668 525 613 778 722 1000 667 667 667 333 606 333 606 500');
  put(p,'333 500 553 444 611 479 333 556 582 291 234 556 291 883 582 546');
  put(p,'601 560 395 424 326 603 565 834 516 556 500 333 606 333 606 606');
  put(p,'0 606 278 500 500 1000 500 500 333 1144 525 331 998 606 667 606');
  put(p,'606 278 278 500 500 606 500 1000 ]');
  put(p,'/Encoding /WinAnsiEncoding');
  put(p,'/BaseFont /Palatino-Roman');
  put(p,'/FontDescriptor ' || to_char(vDescriptor)||' 0 R');
  put(p,'>>');
  put(p,'endobj');
  -- and post it internally
  addFont('Palatino-Roman','Palatino-Roman');
  
  -- Now Palatino-Italic
  vDescriptor := nextObj#(p);
  addXRef(p,vDescriptor,docTable(p).offset, 'Descriptor');
  put( p, to_Char(vDescriptor)||' 0 obj');
  put(p,'<<');
  put(p,'/Type /FontDescriptor');
  put(p,'/Ascent 733');
  put(p,'/CapHeight 692');
  put(p,'/Descent -276');
  put(p,'/Flags 98');
  put(p,'/FontBBox [-170 -276 1010 918]');
  put(p,'/FontName /Palatino-Italic');
  put(p,'/ItalicAngle -10');
  put(p,'/StemV 84');
  put(p,'/XHeight 482');
  put(p,'/StemH 84');
  put(p,'>>');
  put(p,'endobj');
  vFont := nextObj#(p);
  addXref(p,vFont,docTable(p).offset,'imbedded font');
  vPtr := nvl( docTable(p).fontkeyList.last ,0) + 1;
  docTable(p).fontKeyList(vPtr) := 'Palatino-Italic';
  docTable(p).fontObj#List(vPtr) := vFont;
  put(p,to_char(vFont)||' 0 obj');
  put(p,'<<');
  put(p,'/Type /Font');
  put(p,'/Subtype /Type1');
  put(p,'/FirstChar 32');
  put(p,'/LastChar 121');
  put(p,'/Widths [250 333 500 500 500 889 778 333 333 333 389 606 250 333 250 296');
  put(p,'500 500 500 500 500 500 500 500 500 500 250 250 606 606 606 500');
  put(p,'747 722 611 667 778 611 556 722 778 333 333 667 556 944 778 778');
  put(p,'611 778 667 556 611 778 722 944 722 667 667 333 606 333 606 500');
  put(p,'333 444 463 407 500 389 278 500 500 278 278 444 278 778 556 444');
  put(p,'500 463 389 389 333 556 500 722 500 500 ]');
  put(p,'/Encoding /WinAnsiEncoding');
  put(p,'/BaseFont /Palatino-Italic');
  put(p,'/FontDescriptor '||to_char(vDescriptor)||'  0 R');
  put(p,'>>');
  put(p,'endobj');
  addFont('Palatino-Italic','Palatino-Italic');

  -- and Palatino-Bold
  vDescriptor := nextObj#(p);
  addXRef(p,vDescriptor,docTable(p).offset,'Descriptor');
  put(p,to_char(vDescriptor)||' 0 obj');
  put(p,'<<');
  put(p,'/Type /FontDescriptor');
  put(p,'/Ascent 726');
  put(p,'/CapHeight 681');
  put(p,'/Descent -271');
  put(p,'/Flags 262178');
  put(p,'/FontBBox [-152 -266 1000 924]');
  put(p,'/FontName /Palatino-Bold');
  put(p,'/ItalicAngle 0');
  put(p,'/StemV 122');
  put(p,'/XHeight 471');
  put(p,'/StemH 122');
  put(p,'>>');
  put(p,'endobj');
  vFont := nextObj#(p);
  addXref(p,vFont,docTable(p).offset,'imbedded font');
  vPtr := nvl( docTable(p).fontkeyList.last ,0) + 1;
  docTable(p).fontKeyList(vPtr) := 'Palatino-Bold';
  docTable(p).fontObj#List(vPtr) := vFont;
  put(p,to_char(vFont)||' 0 obj');
  put(p,'<<');
  put(p,'/Type /Font');
  put(p,'/Subtype /Type1');
  put(p,'/FirstChar 32');
  put(p,'/LastChar 121');
  put(p,'/Widths [250 278 402 500 500 889 833 227 333 333 444 606 250 333 250 296');
  put(p,'500 500 500 500 500 500 500 500 500 500 250 250 606 606 606 444');
  put(p,'747 778 667 722 833 611 556 833 833 389 389 778 611 1000 833 833');
  put(p,'611 833 722 611 667 778 778 1000 667 667 667 333 606 333 606 500');
  put(p,'333 500 611 444 611 500 389 556 611 333 333 611 333 889 611 556');
  put(p,'611 611 389 444 333 611 556 833 500 556 ]');
  put(p,'/Encoding /WinAnsiEncoding');
  put(p,'/BaseFont /Palatino-Bold');
  put(p,'/FontDescriptor '||to_char(vDescriptor)||' 0 R');
  put(p,'>>');
  put(p,'endobj');
  addFont('Palatino-Bold','Palatino-Bold');


end imbedPalatino;





        
--
-- Package initialization routine
--



begin
  -- now add all the standard fonts
  AddFont('Courier','F1');
  AddFont('Courier-Bold','F1B');
  AddFont('Courier-Oblique','F1I');
  AddFont('Courier-BoldOblique','F1IB');
  AddFont('Helvetica','F2');
  AddFont('Helvetica-Bold','F2B');
  AddFont('Helvetica-Oblique','F2I');
  AddFont('Helvetica-BoldOblique','F2IB');
  AddFont('Times-Roman','F3');
  AddFont('Times-Bold','F3B');
  AddFont('Times-Italic','F3I');
  AddFont('Times-BoldItalic','F3IB');
  AddFont('Symbol','F4');
  AddFont('ZapDingbats','F5');
  pvLicensed := CheckLicense;
END;
/


-- End of DDL Script for Package RANGER.PDF4PLSQL



